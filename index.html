<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>∞ Multiverse — Sagas, Wars, Zombies, Viruses & MechaBots</title>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style>
  :root{
    --bg:#050910; --text:#e9edf4; --muted:#9fb3c7;
    --btn:#0b1220; --btn-border:#1e293b; --glass:#0b1220cc;
    --accent:#7dd3fc; --accent2:#a78bfa; --gold:#fbbf24; --danger:#fb7185; --ok:#34d399;
    --space1:#031126; --space3:#020814;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #stage{position:fixed; inset:0; overflow:hidden; touch-action:none}
  #c{position:absolute; inset:0; width:100%; height:100%;
      background:
        radial-gradient(1400px 900px at 25% 25%, #123a7a 0%, transparent 65%),
        radial-gradient(1200px 800px at 75% 60%, #4b2e83 0%, transparent 60%),
        radial-gradient(1000px 700px at 40% 80%, #0b5e3c 0%, transparent 55%),
        linear-gradient(180deg, var(--space1), var(--space3))}
  #chips{position:fixed; top:10px; left:10px; display:flex; gap:6px; z-index:10}
  .chip{background:#0b1220b8; border:1px solid var(--btn-border); color:var(--muted);
        padding:6px 8px; border-radius:9px; font-size:12px; backdrop-filter:blur(6px)}
  .fab{position:fixed; right:12px; width:56px; height:56px; border-radius:50%;
       background:linear-gradient(#0f172a,#0b1220); border:1px solid #2b3a52; color:#eaf2ff;
       display:grid; place-items:center; font-size:22px; z-index:12; box-shadow:0 12px 24px #0009}
  .fab:active{transform:scale(.98)}
  #fabPlay{bottom:14px} #fabGear{bottom:78px} #fabMap{bottom:142px}
  #fabNew{bottom:206px} #fabCenter{bottom:270px}
  #shade{position:fixed; inset:0; background:rgba(3,10,20,0.45); backdrop-filter:blur(2px);
         opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:19}
  #shade.show{opacity:1; pointer-events:auto}
  #drawer{position:fixed; left:0; right:0; bottom:-72vh; height:min(74vh, 720px);
          background:var(--glass); border-top:1px solid #223046; border-radius:14px 14px 0 0;
          z-index:20; transition:bottom .28s ease; backdrop-filter:blur(12px)}
  #drawer.open{bottom:0}
  #head{display:flex; align-items:center; justify-content:space-between; padding:8px 12px 0 12px}
  #dragbar{height:22px; display:grid; place-items:center; flex:1}
  #dragbar .bar{width:44px; height:5px; border-radius:5px; background:#415a77}
  #closeBtn{border:1px solid #2b3a52; background:#0b1220; color:#e9edf4; width:36px; height:36px; border-radius:10px; font-size:18px}
  #tabs{display:flex; gap:8px; padding:8px 12px}
  .tab{flex:1; text-align:center; padding:10px 8px; border-radius:10px; border:1px solid #2b3a52; background:#0b122060; color:#cfe3ff}
  .tab.active{background:#12213b; color:#fff}
  .page{display:none; padding:8px 12px 16px 12px; height:calc(100% - 88px); overflow:auto}
  .page.show{display:block}
  .section{margin-top:8px}
  .row{display:grid; grid-template-columns:1fr auto; gap:10px; align-items:center; margin:12px 0}
  .label{font-size:14px; color:#d7e4ff}
  .val{font-size:14px; color:#9cc2ff; min-width:52px; text-align:right}
  input[type=range]{-webkit-appearance:none; appearance:none; width:100%; height:42px; background:transparent}
  input[type=range]::-webkit-slider-runnable-track{height:12px; background:#1b2942; border-radius:999px; border:1px solid #2e456b; box-shadow:inset 0 1px 3px #000a}
  input[type=range]::-moz-range-track{height:12px; background:#1b2942; border-radius:999px; border:1px solid #2e456b}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none; width:32px; height:32px; border-radius:50%;
     background:linear-gradient(#22d3ee,#3b82f6); border:2px solid #071424; margin-top:-11px; box-shadow:0 3px 8px #000a}
  input[type=range]::-moz-range-thumb{width:32px; height:32px; border-radius:50%;
     background:linear-gradient(#22d3ee,#3b82f6); border:2px solid #071424; box-shadow:0 3px 8px #000a}
  .btn{border:1px solid #2b3a52; background:#0b1220; color:#e9edf4; border-radius:10px; padding:10px 12px; font-size:14px}
  .btnRow{display:flex; gap:8px; flex-wrap:wrap}
  .panel{background:#0b1220a6; border:1px solid #20314b; border-radius:12px; padding:10px}
  #log{font-family:ui-monospace,SFMono-Regular,Menlo,monospace; font-size:12px; max-height:140px; overflow:auto; white-space:pre-wrap}
  #story{white-space:pre-wrap; line-height:1.3}
  #toast{position:fixed; left:50%; transform:translateX(-50%); bottom:12px; background:#0b1220e0; border:1px solid #1e293b; border-radius:10px; padding:8px 12px; font-size:13px; color:#cbd5e1; z-index:25; display:none}
  #toast.show{display:block}
  /* Floating Map Card */
  #mapCard{position:fixed; top:12px; right:12px; width:min(440px, 86vw); background:#0b1220cc;
           border:1px solid #223046; border-radius:12px; padding:10px; backdrop-filter:blur(10px); z-index:21; display:none}
  #mapCard.show{display:block}
  #mapCardHeader{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
  #mapClose{width:32px; height:32px; border-radius:8px; border:1px solid #2b3a52; background:#0b1220; color:#e9edf4}
  #mapGrid{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  #mapGrid canvas{width:100%; height:160px; background:#0b1220a0; border:1px solid #20314b; border-radius:10px}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>

    <div id="chips">
      <div class="chip" id="statTick">tick 0</div>
      <div class="chip" id="statPop">pop 0</div>
      <div class="chip" id="statUni">universes 0</div>
      <div class="chip" id="statEvents">events 0</div>
    </div>

    <button id="fabCenter" class="fab" title="Center">⊙</button>
    <button id="fabNew" class="fab" title="New universe">⊕</button>
    <button id="fabMap" class="fab" title="Map">🗺</button>
    <button id="fabGear" class="fab" title="Settings">⚙︎</button>
    <button id="fabPlay" class="fab" title="Play/Pause">▶︎</button>

    <div id="toast">Double-tap to play/pause • Pinch to zoom • Drag to pan</div>
  </div>

  <!-- Map Card -->
  <div id="mapCard" aria-hidden="true">
    <div id="mapCardHeader">
      <div style="font-weight:600">Multiverse Map</div>
      <button id="mapClose" title="Close">✕</button>
    </div>
    <div id="mapGrid">
      <canvas id="miniNet"></canvas>
      <canvas id="miniUni"></canvas>
    </div>
  </div>

  <!-- Backdrop for drawer -->
  <div id="shade"></div>

  <!-- Drawer -->
  <aside id="drawer" aria-hidden="true">
    <div id="head">
      <div style="width:36px"></div>
      <div id="dragbar"><div class="bar"></div></div>
      <button id="closeBtn" title="Close">✕</button>
    </div>
    <div id="tabs">
      <button class="tab active" data-page="pageParams">Parameters</button>
      <button class="tab" data-page="pageInspect">Inspect & Log</button>
      <button class="tab" data-page="pageWorld">World</button>
    </div>

    <div id="pageParams" class="page show">
      <div class="panel">
        <div class="row"><div class="label">Mutation</div><div class="val" id="v_mut">0.08</div><input id="pmut" type="range" min="0" max="1" step="0.005" value="0.08"></div>
        <div class="row"><div class="label">Food rate</div><div class="val" id="v_food">1.10</div><input id="pfood" type="range" min="0" max="3" step="0.01" value="1.10"></div>
        <div class="row"><div class="label">Predation</div><div class="val" id="v_pred">0.45</div><input id="ppred" type="range" min="0" max="1" step="0.01" value="0.45"></div>
        <div class="row"><div class="label">Migration</div><div class="val" id="v_mig">0.25</div><input id="pmig" type="range" min="0" max="1" step="0.01" value="0.25"></div>
        <div class="row"><div class="label">Cap/pop</div><div class="val" id="v_cap">300</div><input id="pcap" type="range" min="40" max="800" step="10" value="300"></div>
        <div class="row"><div class="label">Quality</div><div class="val" id="v_qual">1.10</div><input id="pqual" type="range" min="0.5" max="1.6" step="0.05" value="1.10"></div>
        <div class="row"><div class="label">Chaos events</div><div class="val" id="v_events">ON</div><input id="pevents" type="range" min="0" max="1" step="1" value="1"></div>
      </div>
      <div class="btnRow" style="margin-top:10px">
        <button class="btn" id="btnSave">Save</button>
        <button class="btn" id="btnLoad">Load</button>
        <button class="btn" id="btnWipe" title="Reset world">Wipe</button>
        <button class="btn" id="btnStep">Step</button>
        <button class="btn" id="btnHelp">Help</button>
      </div>
    </div>

    <div id="pageInspect" class="page">
      <div class="panel" id="inspect">Tap a creature to see genome, species, lineage & stats.</div>
      <div class="panel" style="margin-top:10px">
        <div style="font-weight:600;margin-bottom:6px">Species Story</div>
        <div id="story">Select a species...</div>
      </div>
      <div class="panel" style="margin-top:10px">
        <div style="font-weight:600;margin-bottom:6px">Chronicle</div>
        <div id="log"></div>
      </div>
    </div>

    <div id="pageWorld" class="page">
      <div class="panel">🗺 Use the Map button to open a floating map. Singularity zones accelerate time; MechaBots hunt zombies and overpredators, heal allies, and drop food.</div>
    </div>
  </aside>

<script>
(function(){
'use strict';

/* ---------- Utilities ---------- */
const DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const TAU=Math.PI*2;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:true});
function cssSize(el){ const r=el.getBoundingClientRect(); return [Math.max(1,r.width), Math.max(1,r.height)]; }
function resizeCanvas(){ const [w,h]=cssSize(canvas), W=Math.floor(w*DPR), H=Math.floor(h*DPR); if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; } }
resizeCanvas(); try{ new ResizeObserver(resizeCanvas).observe(canvas); }catch(_){}
addEventListener('resize', resizeCanvas, {passive:true});
function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,61); return ((t^t>>>14)>>>0)/4294967296; } }
function rndRange(r,a,b){ return a+(b-a)*r(); } function randInt(r,a,b){ return (rndRange(r,a,b+1))|0; } function pick(r,arr){ return arr[(arr.length*r())|0]; }
function hsl(h,s,l,a=1){ return `hsl(${h}deg ${s}% ${l}% / ${a})`; }

/* ---------- UI refs ---------- */
const q = s => document.querySelector(s);
const $tick=q('#statTick'), $pop=q('#statPop'), $uni=q('#statUni'), $ev=q('#statEvents');
const $fabPlay=q('#fabPlay'), $fabGear=q('#fabGear'), $fabMap=q('#fabMap'), $fabNew=q('#fabNew'), $fabCenter=q('#fabCenter');
const $toast=q('#toast'), $drawer=q('#drawer'), $shade=q('#shade'), $close=q('#closeBtn');
const $tabs=[...document.querySelectorAll('.tab')];
const pages={ pageWorld:q('#pageWorld'), pageParams:q('#pageParams'), pageInspect:q('#pageInspect') };
const $mapCard=q('#mapCard'), $mapClose=q('#mapClose');
const miniNet=q('#miniNet'), miniUni=q('#miniUni'); const mNet=miniNet.getContext('2d'), mUni=miniUni.getContext('2d');
const $log=q('#log'), $inspect=q('#inspect'), $story=q('#story');
const sliders = {
  pmut:q('#pmut'), pfood:q('#pfood'), ppred:q('#ppred'), pmig:q('#pmig'), pcap:q('#pcap'), pqual:q('#pqual'), pevents:q('#pevents'),
  v_mut:q('#v_mut'), v_food:q('#v_food'), v_pred:q('#v_pred'), v_mig:q('#v_mig'), v_cap:q('#v_cap'), v_qual:q('#v_qual'), v_events:q('#v_events')
};
function logLine(s){ $log.textContent=(s+"\n"+$log.textContent).slice(0,8000); eventsCount++; }

/* ---------- Drawer & Map ---------- */
let drawerOpen=false;
function setDrawer(open){ drawerOpen=open; $drawer.classList.toggle('open', open); $drawer.setAttribute('aria-hidden', String(!open)); $shade.classList.toggle('show', open); }
$fabGear.onclick=()=>setDrawer(!drawerOpen); $close.onclick=()=>setDrawer(false); $shade.onclick=()=>setDrawer(false);
function activateTab(pageId){ $tabs.forEach(t=>t.classList.toggle('active', t.dataset.page===pageId)); Object.entries(pages).forEach(([id,el])=> el.classList.toggle('show', id===pageId)); }
$tabs.forEach(t=>t.addEventListener('click', ()=>activateTab(t.dataset.page)));
function toggleMapCard(force){ const show = force!==undefined ? force : !$mapCard.classList.contains('show'); $mapCard.classList.toggle('show', show); $mapCard.setAttribute('aria-hidden', String(!show)); if(show) drawMini(); }
$fabMap.onclick=()=>toggleMapCard(); $mapClose.onclick=()=>toggleMapCard(false);

/* ---------- Controls ---------- */
q('#btnHelp').onclick=()=>alert("Controls:\n• Double-tap canvas: play/pause\n• Drag: pan • Pinch/scroll: zoom\n• Tap a creature: inspect → story\n• ⚙️ Settings, 🗺 Map card\n• Wipe fully resets the multiverse.");
q('#btnSave').onclick=()=>saveState(); q('#btnLoad').onclick=()=>loadState(); q('#btnWipe').onclick=()=>wipeWorld();
q('#btnStep').onclick=()=>{ if(running) togglePlay(); stepOnce(); };
function bindSlider(inp, span, prop, fmt=(v)=>v.toFixed(2)){
  inp.addEventListener('input', ()=>{ params[prop]=+inp.value; span.textContent=(prop==='cap')? String(params[prop]) : (prop==='chaos' ? (params[prop]?'ON':'OFF') : fmt(params[prop])); if(prop==='quality'){ for(const u of multiverse.universes.values()) for(const sp of u.species.values()) sp.cachedSprite=null; } });
}
const params={ mutation:+sliders.pmut.value, foodRate:+sliders.pfood.value, predation:+sliders.ppred.value, migration:+sliders.pmig.value, cap:+sliders.pcap.value|0, quality:+sliders.pqual.value, chaos:+sliders.pevents.value|0 };
bindSlider(sliders.pmut,sliders.v_mut,'mutation'); bindSlider(sliders.pfood,sliders.v_food,'foodRate'); bindSlider(sliders.ppred,sliders.v_pred,'predation');
bindSlider(sliders.pmig,sliders.v_mig,'migration'); bindSlider(sliders.pcap,sliders.v_cap,'cap',v=>String(v)); bindSlider(sliders.pqual,sliders.v_qual,'quality',v=>v.toFixed(2));
sliders.pevents.addEventListener('input',()=>{ params.chaos=+sliders.pevents.value|0; sliders.v_events.textContent=params.chaos?'ON':'OFF'; });

/* ---------- Input (pan/zoom) ---------- */
let view={x:0,y:0,z:1};
function screenToWorld(x,y){ return [ (x-canvas.width*0.5)/(view.z*DPR)+view.x, (y-canvas.height*0.5)/(view.z*DPR)+view.y ]; }
let dragging=false,lastX=0,lastY=0, pinch=false,pinchDist=0,pinchStartZ=1,lastTap=0;
canvas.addEventListener('mousedown',e=>{ dragging=true; [lastX,lastY]=[e.clientX,e.clientY]; });
addEventListener('mouseup',()=>dragging=false);
addEventListener('mousemove',e=>{ if(!dragging) return; const dx=e.clientX-lastX,dy=e.clientY-lastY; view.x-=dx/(view.z*DPR); view.y-=dy/(view.z*DPR); [lastX,lastY]=[e.clientX,e.clientY]; });
canvas.addEventListener('wheel',e=>{ e.preventDefault(); const f=(Math.sign(e.deltaY)>0)?1/1.1:1.1; const [wx,wy]=screenToWorld(e.clientX*DPR,e.clientY*DPR); view.z=clamp(view.z*f,0.25,5); const [wx2,wy2]=screenToWorld(e.clientX*DPR,e.clientY*DPR); view.x+=(wx-wx2); view.y+=(wy-wy2); },{passive:false});
canvas.addEventListener('touchstart',e=>{ if(e.touches.length===1){ const t=e.touches[0]; dragging=true; [lastX,lastY]=[t.clientX,t.clientY]; const now=performance.now(); if(now-lastTap<300){ togglePlay(); } lastTap=now; }else if(e.touches.length===2){ pinch=true; dragging=false; const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; pinchDist=Math.hypot(dx,dy); pinchStartZ=view.z; } },{passive:true});
canvas.addEventListener('touchmove',e=>{ if(pinch && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; const f=Math.hypot(dx,dy)/pinchDist; view.z=clamp(pinchStartZ*f,0.25,5); }else if(dragging && e.touches.length===1){ const t=e.touches[0], dx=t.clientX-lastX, dy=t.clientY-lastY; view.x-=dx/(view.z*DPR); view.y-=dy/(view.z*DPR); [lastX,lastY]=[t.clientX,t.clientY]; } },{passive:true});
addEventListener('touchend',()=>{ pinch=false; dragging=false; });

/* ---------- Names & lore ---------- */
const NAME_A=["Auro","Cryo","Nocto","Sapro","Zygo","Luma","Chloro","Myco","Aether","Veloci","Tetra","Hexa","Quasi","Nebulo","Xeno","Paleo","Fracto","Spira","Plasma","Ortho","Iso","Aniso","Glacio","Pyro","Hydro"];
const NAME_B=["phyllum","drome","phyte","morph","zoon","myra","cyst","pod","ther","carid","lith","bion","sema","tode","brach","forma","taxis","ceps","vore","meleon","plex","soma","gaster","arach","gryph"];
function speciesName(r){ return pick(r,NAME_A)+pick(r,NAME_B); }
function makeLore(r, id, name){
  const origin = pick(r,["spawned near a whispering white hole","woven from magnetotides","seeded by cometary rains","awoke within a kelp nebula","hatched in thermal pockets"]);
  const trait = pick(r,["ritual schooling","glimmer mimicry","spiral nesting","orbital dances","fractal camouflage"]);
  const taboo = pick(r,["never pass the silent ring","avoid the violet wake","feed not under cyan auroras","do not circle three times"]);
  const myth = pick(r,["the First Spiral will return","the Healer Machine is kin","the Singularity is a door","zombies are a penance","the virus teaches humility"]);
  const goal = pick(r,["found a reef of plenty","chart all wormholes","tame the mecha guardians","outlive the cold epoch","become light"]);
  return {
    title: `The Song of ${name}`,
    text:
`Origin: ${origin}.
Customs: ${trait}. Taboos: ${taboo}.
Myth: They believe ${myth}.
Dream: To ${goal}.`,
    saga:[`Awakening of ${name} (tick 0).`]
  };
}

/* ---------- Genetics ---------- */
function randomGenome(r){
  const morph=randInt(r,0,4), hue=randInt(r,0,360), sat=rndRange(r,0.65,1), lum=rndRange(r,0.5,0.8);
  const size=rndRange(r,8,18), speed=rndRange(r,18,52), sense=rndRange(r,70,150);
  const dietR=r(); const diet=dietR<0.55?0:(dietR<0.8?2:1); // 0 herb, 1 pred, 2 omni
  const specVar=new Array(6).fill(0).map(()=>rndRange(r,0,1));
  return {morph,hue,sat,lum,size,speed,sense,diet,specVar};
}
function mutateGenome(p,r,rate){
  const g=JSON.parse(JSON.stringify(p));
  function j(v,a){return v+(r()*2-1)*a*rate;}
  if(r()<rate*0.6) g.morph=(g.morph+(r()<0.5?-1:1)+5)%5;
  g.hue=(g.hue+randInt(r,-22,22)+360)%360; g.sat=clamp(j(g.sat,0.28),0.3,1); g.lum=clamp(j(g.lum,0.22),0.35,0.88);
  g.size=clamp(j(g.size,6),6,28); g.speed=clamp(j(g.speed,18),8,70); g.sense=clamp(j(g.sense,55),30,220);
  if(r()<rate*0.5) g.diet=randInt(r,0,2);
  for(let i=0;i<g.specVar.length;i++) g.specVar[i]=clamp(j(g.specVar[i],0.7),0,1);
  return g;
}

/* ---------- Entities ---------- */
let nextSpeciesId=1, simTick=0, eventsCount=0;
function makeSpecies(u,parentId=null,parentGenome=null){
  const genome=parentGenome?mutateGenome(parentGenome,u.rng,params.mutation*0.8):randomGenome(u.rng);
  const id=nextSpeciesId++, name=speciesName(u.rng); const lore=makeLore(u.rng,id,name);
  return {id,name,genome,parent:parentId,birthTick:simTick,totalBorn:0,totalDeaths:0,bestAge:0,expansions:0,cachedSprite:null,spriteScale:1,lore, saga:lore.saga};
}
function makeCreature(u,sp,x,y){
  const ang=u.rng()*TAU;
  return {x,y,vx:Math.cos(ang)*0.1,vy:Math.sin(ang)*0.1,ang,energy:60+u.rng()*40,age:0,speciesId:sp.id,cooldown:0,blink:0,id:(u.id+"-"+Math.random()).slice(0,18), virus:null, zombie:false};
}
function makeFood(u){ return {x:rndRange(u.rng,0,u.size), y:rndRange(u.rng,0,u.size), v:rndRange(u.rng,6,12)}; }
function makeMecha(u){ const a=u.rng()*TAU; const role=pick(u.rng,["hunter","guardian","medic"]); return {x:rndRange(u.rng,100,u.size-100), y:rndRange(u.rng,100,u.size-100), vx:Math.cos(a)*0.4, vy:Math.sin(a)*0.4, role, energy:200, cooldown:0, id:"M-"+Math.random().toString(36).slice(2)}; }

/* ---------- Universe ---------- */
class Universe{
  constructor(id,seed,size=1200){
    this.id=id; this.size=size; this.seed=seed; this.rng=mulberry32(seed);
    this.creatures=[]; this.food=[]; this.species=new Map(); this.holes=[]; this.mecha=[];
    this.gridSize=60; this.grid=new Map(); this.chronicle=[];
    this.kills=new Map(); this.wars=[]; // kills key "a-b"
    this.spawnInitial(); this.createBlackHoles(); this.spawnMecha();
  }
  log(s){ this.chronicle.unshift({t:simTick,s}); if(this===multiverse.currentUniverse()) logLine("U"+this.id+": "+s); if(this.chronicle.length>150) this.chronicle.pop(); }
  spawnInitial(){
    for(let s=0;s<3;s++){
      const sp=makeSpecies(this); this.species.set(sp.id,sp);
      for(let i=0;i<28;i++){ const x=rndRange(this.rng,200,this.size-200), y=rndRange(this.rng,200,this.size-200); this.creatures.push(makeCreature(this,sp,x,y)); sp.totalBorn++; }
    }
    for(let i=0;i<280;i++) this.food.push(makeFood(this));
    this.log(`Universe ${this.id} awakens with ${this.creatures.length} lifeforms.`);
  }
  spawnMecha(){ for(let i=0;i<3;i++) this.mecha.push(makeMecha(this)); }
  createBlackHoles(){
    const n=randInt(this.rng,2,3); this.holes=[];
    for(let i=0;i<n;i++){
      const pos=[rndRange(this.rng,120,this.size-120), this.rng()<0.5?rndRange(this.rng,40,100):rndRange(this.rng,this.size-100,this.size-40)];
      if(this.rng()<0.5) pos.reverse();
      const nested = this.rng()<0.5; // nested black-hole ➜ white-hole
      this.holes.push({x:pos[0],y:pos[1],r:48,angle:this.rng()*TAU,link:null,nested});
    }
  }
  clearGrid(){ this.grid.clear(); }
  cellKey(x,y){ return ((x/this.gridSize)|0)+"," + ((y/this.gridSize)|0); }
  addToGrid(c){ const k=this.cellKey(c.x,c.y); let a=this.grid.get(k); if(!a){a=[]; this.grid.set(k,a);} a.push(c); }
  neighbors(x,y,rad){
    const r=(rad/this.gridSize|0)+1, cx=(x/this.gridSize|0), cy=(y/this.gridSize|0), out=[];
    for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++){ const a=this.grid.get((cx+dx)+","+(cy+dy)); if(a) out.push(...a); }
    return out;
  }
  killCount(a,b){ const k=a+"-"+b; return this.kills.get(k)||0; }
  addKill(a,b){ const k=a+"-"+b; this.kills.set(k,(this.kills.get(k)||0)+1); }
  ensureWar(a,b){
    if(a===b) return;
    let w=this.wars.find(w=> (w.a===a&&w.b===b)||(w.a===b&&w.b===a) && w.status==="ongoing");
    if(!w){
      w={a,b,start:simTick,ca:0,cb:0,status:"ongoing"}; this.wars.push(w);
      const A=this.species.get(a), B=this.species.get(b);
      if(A&&B){ A.saga.push(`War declared against ${B.name} at tick ${simTick}.`); B.saga.push(`War declared against ${A.name} at tick ${simTick}.`); }
      this.log(`⚔️ War ignites: ${A?A.name:a} ↔ ${B?B.name:b}`);
    }
    return w;
  }
  maybeEndWar(w){
    if(w.status!=="ongoing") return;
    if(simTick-w.start>1200 && Math.abs(w.ca-w.cb)<5){ // stalemate peace
      w.status="peace"; const A=this.species.get(w.a), B=this.species.get(w.b);
      if(A&&B){ A.saga.push(`Peace with ${B.name} at tick ${simTick}.`); B.saga.push(`Peace with ${A.name} at tick ${simTick}.`); }
      this.log(`🕊️ Peace declared between ${A?A.name:w.a} and ${B?B.name:w.b}.`);
    }
  }
  outbreak(kind){
    if(kind==="zombie"){
      const sp=makeSpecies(this); sp.name="Necros" + randInt(this.rng,100,999);
      this.species.set(sp.id,sp);
      for(let i=0;i<10;i++){ const x=rndRange(this.rng,250,this.size-250), y=rndRange(this.rng,250,this.size-250); const c=makeCreature(this,sp,x,y); c.zombie=true; this.creatures.push(c); sp.totalBorn++; }
      sp.saga.push(`❗ Zombie outbreak at tick ${simTick}.`);
      this.log(`🧟 Zombie outbreak: ${sp.name} shambles forth.`);
    }else if(kind==="virus"){
      // Seed random infections
      const victims=this.creatures.slice(0, Math.min(20, (this.creatures.length*0.15)|0));
      victims.forEach(v=> v.virus={ttl:randInt(this.rng,600,1200), speed:0.7, drain:0.06});
      this.log(`☣️ Viral wave weakens ${victims.length} organisms.`);
    }else if(kind==="apocalypse"){
      // famine + meteor (cull food) + radiation (energy drain)
      this.food.splice(0, (this.food.length*0.7)|0);
      for(const c of this.creatures){ c.energy*=0.7; }
      this.log(`☄️ Apocalypse event: famine & meteors ravage the land.`);
    }
  }
  step(dt){
    // Ambient food spawn
    const want=Math.max(80, params.cap*0.85);
    const deficit=Math.max(0, want-(this.food.length*2));
    for(let i=0;i<((params.foodRate*deficit*0.025)|0);i++) this.food.push(makeFood(this));

    // Chaos events
    if(params.chaos && this.rng()<0.0008){ this.outbreak(pick(this.rng,["zombie","virus","apocalypse"])); }

    // Grid
    this.clearGrid(); for(const c of this.creatures) this.addToGrid(c);

    // Mecha behavior (simple)
    for(const m of this.mecha){
      m.energy-=0.02; if(m.cooldown>0) m.cooldown-=dt;
      // targets: zombies first, then dominant predators
      let target=null, tDist=1e9;
      for(const c of this.creatures){
        const sp=this.species.get(c.speciesId); if(!sp) continue;
        const isPred=this.species.get(c.speciesId)?.genome.diet===1;
        const priority = c.zombie ? 3 : (isPred?1:0);
        if(priority===0 && m.role==="guardian") continue;
        if(priority>0){
          const dx=c.x-m.x,dy=c.y-m.y,d2=dx*dx+dy*dy; if(d2<tDist){ tDist=d2; target=c; }
        }
      }
      // assist herbivores by dropping food
      if(!target && m.role!=="hunter" && m.cooldown<=0){
        const friend=this.creatures.find(c=> this.species.get(c.speciesId)?.genome.diet===0 );
        if(friend){ this.food.push({x:friend.x+this.rng()*8-4, y:friend.y+this.rng()*8-4, v:10}); m.cooldown=4; this.log(`🤖 Mecha ${m.role} drops supply near herbivores.`); }
      }
      // move
      let ax=0,ay=0;
      if(target){ const dx=target.x-m.x, dy=target.y-m.y, d=Math.hypot(dx,dy)+1e-6; ax+=dx/d*0.8; ay+=dy/d*0.8; }
      m.vx=clamp(m.vx+ax*dt,-1.2,1.2); m.vy=clamp(m.vy+ay*dt,-1.2,1.2);
      const vlen=Math.hypot(m.vx,m.vy); if(vlen>0){ const spd=0.6; m.vx=m.vx/vlen*spd; m.vy=m.vy/vlen*spd; }
      m.x+=m.vx; m.y+=m.vy;

      // actions
      if(target && Math.hypot(target.x-m.x,target.y-m.y)<10 && m.cooldown<=0){
        if(target.zombie || this.species.get(target.speciesId)?.genome.diet===1){
          // zap
          const idx=this.creatures.indexOf(target); if(idx>=0){ const tsp=this.species.get(target.speciesId); if(tsp) tsp.totalDeaths++; this.creatures.splice(idx,1); this.log(`⚡ Mecha neutralized ${tsp?tsp.name:"entity"}.`); }
          m.cooldown=3;
        }
      }
      // boundary nudges
      if(m.x<30) m.vx+=0.2; if(m.y<30) m.vy+=0.2; if(m.x>this.size-30) m.vx-=0.2; if(m.y>this.size-30) m.vy-=0.2;
    }

    // Creatures
    const removal=[];
    for(const c of this.creatures){
      const sp=this.species.get(c.speciesId); if(!sp){ removal.push(c); continue; }
      const g=sp.genome;

      // Virus effects
      if(c.virus){ c.virus.ttl--; c.energy-=c.virus.drain; if(c.virus.ttl<=0) c.virus=null; }

      // Singularity acceleration if near nested hole
      let localDt=dt;
      for(const h of this.holes){ const d=Math.hypot(c.x-h.x,c.y-h.y); if(d<h.r*0.8 && h.nested){ localDt*=1.75; if(this.rng()<0.0006 && h.link){ // rare fling
            multiverse.migrate(c,this,h,true); c.blink=0.4; this.log(`🕳️ Singularity cascade flung a ${sp.name} through a white hole.`); } } }

      // Energy & age
      c.age+=localDt; c.energy-=0.03+g.speed*0.0002+g.size*0.0004;

      // Seek targets
      let tx=null,ty=null,tDist=1e9,target=null,targetType=null;
      const neigh=this.neighbors(c.x,c.y,g.sense);
      // if zombie: hunt anyone non-zombie
      if(c.zombie){
        for(const o of neigh){ if(o===c) continue; if(o.zombie) continue; const dx=o.x-c.x,dy=o.y-c.y,d2=dx*dx+dy*dy; if(d2<tDist){ tDist=d2; tx=o.x; ty=o.y; target=o; targetType='infect'; } }
      }else{
        if(g.diet===0||g.diet===2){ for(const f of this.food){ const dx=f.x-c.x,dy=f.y-c.y,d2=dx*dx+dy*dy; if(d2<tDist && d2<g.sense*g.sense){ tDist=d2; tx=f.x; ty=f.y; target=f; targetType='food'; } } }
        if(g.diet===1||g.diet===2){
          for(const o of neigh){ if(o===c) continue; const osp=this.species.get(o.speciesId);
            if(osp && osp.genome.size < g.size*0.95){ const dx=o.x-c.x,dy=o.y-c.y,d2=dx*dx+dy*dy; if(d2<tDist && d2<g.sense*g.sense){ tDist=d2; tx=o.x; ty=o.y; target=o; targetType='prey'; } }
          }
        }
      }

      // Motion
      let ax=0,ay=0; c.ang+=(Math.random()-0.5)*0.2; ax+=Math.cos(c.ang)*0.55; ay+=Math.sin(c.ang)*0.55;
      if(tx!=null){ const dx=tx-c.x,dy=ty-c.y,d=Math.hypot(dx,dy)+1e-6; ax+=dx/d*1.25; ay+=dy/d*1.25; }
      const m=110; if(c.x<m) ax+=0.65; if(c.y<m) ay+=0.65; if(c.x>this.size-m) ax-=0.65; if(c.y>this.size-m) ay-=0.65;
      c.vx=clamp(c.vx+ax*localDt,-2.2,2.2); c.vy=clamp(c.vy+ay*localDt,-2.2,2.2);
      let spd=g.speed*0.021; if(c.virus) spd*=c.virus.speed;
      const vlen=Math.hypot(c.vx,c.vy); if(vlen>0){ c.vx=c.vx/vlen*spd; c.vy=c.vy/vlen*spd; }
      c.x+=c.vx; c.y+=c.vy;

      // Interactions
      if(targetType==='food'){
        if(Math.hypot(target.x-c.x,target.y-c.y)<g.size*0.85){ c.energy+=target.v; this.food.splice(this.food.indexOf(target),1); c.blink=0.25; }
      }else if(targetType==='prey' && Math.random()<params.predation){
        if(Math.hypot(target.x-c.x,target.y-c.y)<(g.size*0.62)){
          const idx=this.creatures.indexOf(target); if(idx>=0){
            this.creatures.splice(idx,1);
            const tsp=this.species.get(target.speciesId); if(tsp) { tsp.totalDeaths++; this.addKill(sp.id,tsp.id); }
            c.energy+=42; c.blink=0.28;
            // escalate war if heavy casualties
            if(this.killCount(sp.id,tsp.id)>=12) this.ensureWar(sp.id,tsp.id);
          }
        }
      }else if(targetType==='infect'){
        if(Math.hypot(target.x-c.x,target.y-c.y)<(g.size*0.7)){
          target.zombie=true; target.energy+=20; c.energy+=20; this.log(`🧟 Infection spreads among ${this.species.get(target.speciesId)?.name||"creatures"}.`);
        }
      }

      // Mecha heal if close (medic)
      for(const m of this.mecha){ if(m.role==="medic" && Math.hypot(m.x-c.x,m.y-c.y)<16 && m.cooldown<=0){ c.energy+=15; c.blink=0.2; m.cooldown=3; } }

      // Reproduce
      if(!c.zombie && c.energy>122 && c.cooldown<=0 && this.creatures.length<params.cap){
        c.energy*=0.5; c.cooldown=2.2;
        let childSpecies=sp;
        if(Math.random()<params.mutation*0.25){
          const newSp=makeSpecies(this, sp.id, sp.genome); this.species.set(newSp.id,newSp); this.log(`🌱 Speciation: ${sp.name} → ${newSp.name}`); childSpecies=newSp;
        }
        const cc=makeCreature(this,childSpecies,c.x+(Math.random()*8-4),c.y+(Math.random()*8-4));
        if(Math.random()<params.mutation*0.6){ childSpecies.genome=mutateGenome(childSpecies.genome,this.rng,params.mutation*0.5); childSpecies.cachedSprite=null; }
        this.creatures.push(cc); childSpecies.totalBorn++;
      }

      // Death / cleanup
      if(c.energy<=0 || c.age>1800) removal.push(c);
      // Migration via holes (normal)
      if(Math.random()<params.migration*0.02){ for(const h of this.holes){ if(Math.hypot(c.x-h.x,c.y-h.y)<h.r*0.92 && h.link){ multiverse.migrate(c,this,h,false); break; } } }
    }

    // Cull & finalize
    for(const c of removal){ const sp=this.species.get(c.speciesId); if(sp) sp.totalDeaths++; const i=this.creatures.indexOf(c); if(i>=0) this.creatures.splice(i,1); }
    if(this.creatures.length>params.cap*1.2){
      this.creatures.sort((a,b)=>(a.energy+a.age*0.2)-(b.energy+b.age*0.2));
      const kill=(this.creatures.length-params.cap)|0; for(let i=0;i<kill;i++){ const c=this.creatures[i]; const sp=this.species.get(c.speciesId); if(sp) sp.totalDeaths++; }
      this.creatures.splice(0,kill); this.log(`Culled ${kill} to stabilize.`);
    }
    for(const sp of this.species.values()){ let best=0; for(const c of this.creatures){ if(c.speciesId===sp.id && c.age>best) best=c.age; } sp.bestAge=Math.max(sp.bestAge,best); }
    if(this.creatures.length===0){
      const sp=makeSpecies(this); this.species.set(sp.id,sp);
      for(let i=0;i<16;i++){ const x=rndRange(this.rng,220,this.size-220), y=rndRange(this.rng,220,this.size-220); this.creatures.push(makeCreature(this,sp,x,y)); }
      this.log("🌌 Biosphere rebooted.");
    }

    // Maybe resolve wars
    for(const w of this.wars){ this.maybeEndWar(w); }
  }
}

/* ---------- Multiverse ---------- */
const multiverse={
  universes:new Map(), edges:[], currentId:1, rng:mulberry32((Date.now()*2654435761)>>>0),
  currentUniverse(){ return this.universes.get(this.currentId); },
  ensureUniverse(id){ if(this.universes.has(id)) return this.universes.get(id); const u=new Universe(id, randInt(this.rng,1,2**31-1)); this.universes.set(id,u); return u; },
  connect(a,b){
    const ua=this.ensureUniverse(a), ub=this.ensureUniverse(b);
    const ha=ua.holes.find(h=>!h.link)||ua.holes[0], hb=ub.holes.find(h=>!h.link)||ub.holes[0];
    ha.link={universe:b,hole:hb,white:true}; hb.link={universe:a,hole:ha,white:true}; this.edges.push({a,b,aHole:ha,bHole:hb});
    ua.log(`Wormhole opened to U${b}.`); ub.log(`Wormhole opened to U${a}.`);
  },
  addUniverseNearCurrent(){
    const newId=this.universes.size? Math.max(...this.universes.keys())+1:1;
    this.ensureUniverse(newId);
    if(this.universes.size>1) this.connect(this.currentId,newId);
    drawMini();
  },
  migrate(creature, fromU, holeA, boosted){
    const link=holeA.link; if(!link) return;
    const toU=this.ensureUniverse(link.universe);
    if(!toU.species.has(creature.speciesId)){
      const spFrom=fromU.species.get(creature.speciesId);
      if(spFrom){ toU.species.set(spFrom.id, {...JSON.parse(JSON.stringify(spFrom)), cachedSprite:null, spriteScale:1}); }
    }
    const idx=fromU.creatures.indexOf(creature); if(idx>=0) fromU.creatures.splice(idx,1);
    const toHole=link.hole; creature.x=toHole.x+(Math.random()*6-3); creature.y=toHole.y+(Math.random()*6-3);
    if(boosted){ creature.energy+=20; }
    creature.vx*=0.5; creature.vy*=0.5; creature.blink=0.4; toU.creatures.push(creature);
    const sp=toU.species.get(creature.speciesId); if(sp) sp.expansions++; toU.log(`Migration: one ${sp?sp.name:"organism"} arrived.`);
  }
};

/* ---------- Sprites ---------- */
function getSpeciesSprite(u,sp){
  if(!sp) return null; if(sp.cachedSprite && sp.spriteScale===params.quality) return sp.cachedSprite;
  const g=sp.genome, scale=g.size*params.quality, sz=Math.max(36, Math.min(200, (scale*7.5)|0));
  const oc=document.createElement('canvas'); oc.width=oc.height=sz; const cx=oc.getContext('2d');
  cx.translate(sz/2, sz/2); cx.scale(scale/18, scale/18);
  const fill=hsl(g.hue, Math.round(72+g.sat*28), Math.round(48+g.lum*30));
  const stroke=hsl((g.hue+24)%360,60,20);
  cx.shadowColor=hsl(g.hue,100,60,0.35); cx.shadowBlur=8;
  switch(g.morph){ case 0: drawRadiate(cx,g,fill,stroke); break; case 1: drawBilateral(cx,g,fill,stroke); break; case 2: drawOrbital(cx,g,fill,stroke); break; case 3: drawSpiralShell(cx,g,fill,stroke); break; case 4: drawLeafFrond(cx,g,fill,stroke); break; }
  // eye
  cx.save(); cx.rotate((g.specVar[4]-0.5)*0.8); cx.fillStyle='white'; cx.beginPath(); cx.ellipse(4,-2,2.6,1.7,0,0,TAU); cx.fill();
  cx.fillStyle='black'; cx.beginPath(); cx.ellipse(4,-2,1.1,0.75,0,0,TAU); cx.fill(); cx.restore();
  sp.cachedSprite=oc; sp.spriteScale=params.quality; return oc;
}
function superPath(cx,m,n1,n2,n3,steps,scale=12,jitter=0){ cx.beginPath(); for(let i=0;i<=steps;i++){ const phi=TAU*i/steps,a=1,b=1; const t1=Math.pow(Math.abs(Math.cos(m*phi/4)/a),n2); const t2=Math.pow(Math.abs(Math.sin(m*phi/4)/b),n3); let r=Math.pow(t1+t2,-1/n1); if(!isFinite(r)) r=0; if(jitter) r*=1+(Math.sin(phi*5+(steps%13))*jitter); const x=r*Math.cos(phi)*scale,y=r*Math.sin(phi)*scale; i?cx.lineTo(x,y):cx.moveTo(x,y);} cx.closePath(); }
function drawRadiate(cx,g,fill,stroke){ const m=5+(g.specVar[0]*5|0); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=2.0; superPath(cx,m,0.6+g.specVar[1]*1.4,5,12,240,16,0.05*g.specVar[2]); cx.fill(); cx.stroke(); cx.save(); cx.globalAlpha=0.28; cx.fillStyle=hsl((g.hue+310)%360,85,70); superPath(cx,m+1,0.8,8,4,200,10,0); cx.fill(); cx.restore(); cx.strokeStyle=hsl(g.hue,85,60,0.7); cx.lineWidth=1.3; const arms=6+(g.specVar[3]*6|0); for(let i=0;i<arms;i++){ const a=TAU*i/arms+g.specVar[4]*0.7; cx.beginPath(); cx.moveTo(Math.cos(a)*6,Math.sin(a)*6); const len=11+g.specVar[5]*17; for(let k=1;k<=4;k++){ const t=k/4; const x=Math.cos(a)*(6+t*len)+Math.sin(a*3+t*2)*1.6; const y=Math.sin(a)*(6+t*len)+Math.cos(a*4+t*3)*1.6; cx.lineTo(x,y);} cx.stroke(); } }
function drawBilateral(cx,g,fill,stroke){ cx.save(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=2.2; cx.beginPath(); cx.moveTo(10,0); cx.bezierCurveTo(6,-8,-4,-10,-10,0); cx.bezierCurveTo(-4,10,6,8,10,0); cx.closePath(); cx.fill(); cx.stroke(); const legs=3+(g.specVar[0]*5|0); cx.strokeStyle=hsl((g.hue+40)%360,60,60); cx.lineWidth=1.4; for(let i=0;i<legs;i++){ const y=-6+i*(12/(legs-1)); cx.beginPath(); cx.moveTo(-4,y); cx.quadraticCurveTo(-12,y-2,-14,y+(i%2?3:-3)); cx.moveTo(4,y); cx.quadraticCurveTo(12,y+2,14,y+(i%2?-3:3)); cx.stroke(); } cx.beginPath(); cx.moveTo(6,-3); cx.quadraticCurveTo(12,-10,14,-12); cx.moveTo(6,3); cx.quadraticCurveTo(12,10,14,12); cx.stroke(); cx.globalAlpha=0.34; cx.fillStyle='white'; for(let i=0;i<5;i++){ cx.fillRect(-2+i*2-5,-8,1,16);} cx.restore(); }
function drawOrbital(cx,g,fill,stroke){ cx.save(); const ring=10+g.specVar[0]*8; cx.strokeStyle=hsl(g.hue,90,65,0.9); cx.lineWidth=1.6; cx.beginPath(); cx.ellipse(0,0,ring,ring*0.6,g.specVar[1]*0.9,0,TAU); cx.stroke(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=2.0; cx.beginPath(); cx.arc(0,0,7+g.specVar[2]*4,0,TAU); cx.fill(); cx.stroke(); const pods=3+(g.specVar[3]*5|0); cx.fillStyle=hsl((g.hue+260)%360,85,72); for(let i=0;i<pods;i++){ const a=TAU*i/pods+g.specVar[4]*1.2; cx.beginPath(); cx.arc(Math.cos(a)*ring,Math.sin(a)*ring*0.6,2+g.specVar[5]*2,0,TAU); cx.fill(); } cx.restore(); }
function drawSpiralShell(cx,g,fill,stroke){ cx.save(); const turns=2.2+g.specVar[0]*2; cx.strokeStyle=stroke; cx.lineWidth=1.8; cx.beginPath(); for(let t=0;t<1;t+=1/140){ const a=t*TAU*turns, r=3+12*t, x=r*Math.cos(a), y=r*Math.sin(a); t?cx.lineTo(x,y):cx.moveTo(x,y);} cx.stroke(); cx.strokeStyle=hsl((g.hue+20)%360,60,58,0.8); cx.lineWidth=1.2; for(let i=0;i<11;i++){ const t=i/10,a=t*TAU*turns,r=3+12*t,x=r*Math.cos(a),y=r*Math.sin(a),nx=Math.cos(a+Math.PI/2),ny=Math.sin(a+Math.PI/2); cx.beginPath(); cx.moveTo(x,y); cx.lineTo(x+nx*3,y+ny*3); cx.stroke(); } cx.globalAlpha=0.4; cx.fillStyle=fill; cx.beginPath(); cx.arc(0,0,12,0,TAU); cx.fill(); cx.restore(); }
function drawLeafFrond(cx,g,fill,stroke){ cx.save(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=1.8; cx.beginPath(); cx.moveTo(-12,0); cx.quadraticCurveTo(0,-10,12,0); cx.quadraticCurveTo(0,10,-12,0); cx.closePath(); cx.fill(); cx.stroke(); cx.strokeStyle=hsl((g.hue+90)%360,55,62); cx.beginPath(); cx.moveTo(-10,0); cx.lineTo(10,0); cx.stroke(); cx.globalAlpha=0.9; cx.lineWidth=1.2; for(let i=0;i<6;i++){ const t=-8+i*3.2; cx.beginPath(); cx.moveTo(t,0); cx.quadraticCurveTo(t+2,-4,t+4,-6); cx.stroke(); cx.beginPath(); cx.moveTo(t,0); cx.quadraticCurveTo(t+2,4,t+4,6); cx.stroke(); } cx.restore(); }

/* ---------- Rendering (hard clear each frame) ---------- */
function drawUniverse(u){
  ctx.setTransform(1,0,0,1,0,0); // reset
  ctx.clearRect(0,0,canvas.width,canvas.height); // full clear

  // World space
  ctx.save();
  ctx.translate(canvas.width/2,canvas.height/2);
  ctx.scale(view.z*DPR,view.z*DPR);
  ctx.translate(-view.x,-view.y);

  // Domain border
  ctx.strokeStyle='rgba(110,231,255,0.22)'; ctx.lineWidth=2.2/view.z/DPR; ctx.strokeRect(0,0,u.size,u.size);

  // Food
  ctx.fillStyle='rgba(172,255,120,0.95)';
  for(const f of u.food){ ctx.beginPath(); ctx.arc(f.x,f.y, 1.8+f.v*0.05, 0, TAU); ctx.fill(); }

  // Portals (nested holes glow differently)
  for(const h of u.holes){
    const grad=ctx.createRadialGradient(h.x,h.y,6,h.x,h.y,h.r);
    grad.addColorStop(0,h.nested?'rgba(255,255,255,0.95)':'rgba(147,51,234,0.95)');
    grad.addColorStop(0.45,h.nested?'rgba(2,132,199,0.85)':'rgba(2,132,199,0.75)');
    grad.addColorStop(1,'rgba(2,6,23,0.05)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,TAU); ctx.fill();
    ctx.strokeStyle=h.nested?'rgba(255,255,255,0.8)':'rgba(56,189,248,0.9)'; ctx.lineWidth=1.8/view.z/DPR; ctx.beginPath();
    for(let t=0;t<TAU;t+=TAU/64){ const r=h.r*0.68+Math.sin(t*4+simTick*0.06)*2.4; const x=h.x+Math.cos(t+h.angle)*r, y=h.y+Math.sin(t+h.angle)*r; t===0?ctx.moveTo(x,y):ctx.lineTo(x,y); }
    ctx.closePath(); ctx.stroke(); if(h.link){ ctx.fillStyle='rgba(251,191,36,0.95)'; ctx.fillRect(h.x-2,h.y-2,4,4); }
  }

  // Creatures
  for(const c of u.creatures){
    const sp=u.species.get(c.speciesId); if(!sp) continue;
    const sprite=getSpeciesSprite(u,sp); if(!sprite) continue;
    ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(Math.atan2(c.vy,c.vx));
    ctx.globalAlpha= c.blink>0 ? 1 : 0.98;
    ctx.drawImage(sprite, -sprite.width*0.02, -sprite.height*0.02, sprite.width*0.04, sprite.height*0.04);
    if(c.zombie){ ctx.strokeStyle='rgba(255,60,80,0.9)'; ctx.lineWidth=1.8/view.z/DPR; ctx.beginPath(); ctx.arc(0,0,16,0,TAU); ctx.stroke(); }
    if(c.virus){ ctx.strokeStyle='rgba(147,197,114,0.9)'; ctx.lineWidth=1.4/view.z/DPR; ctx.beginPath(); ctx.arc(0,0,13,0,TAU); ctx.stroke(); }
    ctx.restore();
  }

  // Mecha
  for(const m of u.mecha){
    ctx.save(); ctx.translate(m.x,m.y);
    ctx.fillStyle=m.role==="hunter"?'#60a5fa':(m.role==="guardian"?'#fbbf24':'#34d399');
    ctx.strokeStyle='#0b1220'; ctx.lineWidth=1.8/view.z/DPR;
    ctx.beginPath(); ctx.moveTo(-8,-6); ctx.lineTo(8,-6); ctx.lineTo(0,10); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  // Selection marker
  if(selected && selected.u===u && selected.c){
    ctx.save(); ctx.strokeStyle='rgba(251,191,36,0.95)'; ctx.lineWidth=2.2/view.z/DPR; ctx.beginPath(); ctx.arc(selected.c.x,selected.c.y,16,0,TAU); ctx.stroke(); ctx.restore();
  }

  ctx.restore();
}

/* ---------- Minimap ---------- */
function resizeMini(){ miniNet.width=miniNet.clientWidth*DPR; miniNet.height=miniNet.clientHeight*DPR; miniUni.width=miniUni.clientWidth*DPR; miniUni.height=miniUni.clientHeight*DPR; }
try{ new ResizeObserver(resizeMini).observe(miniNet); new ResizeObserver(resizeMini).observe(miniUni); }catch(_){}
function drawMini(){
  resizeMini();
  mNet.clearRect(0,0,miniNet.width,miniNet.height);
  const nodes=Array.from(multiverse.universes.keys()); if(!nodes.length) return;
  const w=miniNet.width,h=miniNet.height,r=Math.min(w,h)*0.35; const pos=new Map();
  nodes.forEach((id,i)=>{ const a=TAU*i/nodes.length; pos.set(id,[w/2+Math.cos(a)*r,h/2+Math.sin(a)*r]); });
  mNet.strokeStyle='rgba(125,211,252,0.7)'; mNet.lineWidth=2;
  for(const e of multiverse.edges){ const [ax,ay]=pos.get(e.a), [bx,by]=pos.get(e.b); mNet.beginPath(); mNet.moveTo(ax,ay); mNet.lineTo(bx,by); mNet.stroke(); }
  for(const id of nodes){ const [x,y]=pos.get(id); const u=multiverse.universes.get(id), pop=u.creatures.length; mNet.fillStyle=id===multiverse.currentId?'#facc15':'#38bdf8'; mNet.beginPath(); mNet.arc(x,y,8+Math.min(8,pop/80),0,TAU); mNet.fill(); mNet.fillStyle='#e5eefb'; mNet.font=`${12*DPR}px system-ui`; mNet.textAlign='center'; mNet.fillText(id,x,y-14); }
  miniNet.onclick=(e)=>{ const r=miniNet.getBoundingClientRect(); const x=(e.clientX-r.left)*DPR, y=(e.clientY-r.top)*DPR; for(const [id,p] of pos){ if(Math.hypot(x-p[0], y-p[1])<14*DPR){ multiverse.currentId=id; centerView(); break; } } };
  // Local
  mUni.clearRect(0,0,miniUni.width,miniUni.height); const u=multiverse.currentUniverse(); if(!u) return;
  const sc=Math.min(miniUni.width,miniUni.height)/(u.size*1.1), tx=x=>x*sc+miniUni.width*0.05, ty=y=>y*sc+miniUni.height*0.05;
  mUni.strokeStyle='rgba(148,163,184,0.6)'; mUni.strokeRect(tx(0),ty(0),u.size*sc,u.size*sc);
  mUni.fillStyle='rgba(172,255,120,0.95)'; for(const f of u.food){ mUni.fillRect(tx(f.x),ty(f.y),1,1); }
  mUni.fillStyle='rgba(251,191,36,0.95)'; for(const h of u.holes){ mUni.beginPath(); mUni.arc(tx(h.x),ty(h.y),6,0,TAU); mUni.fill(); }
}

/* ---------- Selection & Story ---------- */
let selected=null;
canvas.addEventListener('click', e=>{
  const rect=canvas.getBoundingClientRect();
  const [wx,wy]=screenToWorld((e.clientX-rect.left)*DPR, (e.clientY-rect.top)*DPR);
  const u=multiverse.currentUniverse(); let best=null,bd=20;
  for(const c of u.creatures){ const d=Math.hypot(c.x-wx,c.y-wy); if(d<bd){ bd=d; best=c; } }
  if(best){ selected={u,c:best}; showInspect(best,u); setDrawer(true); activateTab('pageInspect'); }
});
function showInspect(c,u){
  const sp=u.species.get(c.speciesId), parent=sp.parent?u.species.get(sp.parent):null, t=sp.genome;
  $inspect.innerHTML=`<div style="font-weight:600">${sp.name} <span style="color:#9fb3c7">[Species #${sp.id}]</span></div>
    <div style="color:#9fb3c7">Parent: ${parent? parent.name+" (#"+parent.id+")":"— root"}</div>
    <div>Diet: ${["Herbivore","Predator","Omnivore"][t.diet]} • Morph: ${["Radiate","Bilateral","Orbital","Shell","Frond"][t.morph]}</div>
    <div>HSL: ${t.hue} / ${t.sat.toFixed(2)} / ${t.lum.toFixed(2)}</div>
    <div>Size: ${t.size.toFixed(1)} • Speed: ${t.speed.toFixed(1)} • Sense: ${t.sense.toFixed(0)}</div>
    <div>Creature age: ${c.age.toFixed(1)} • energy: ${c.energy.toFixed(0)} ${c.zombie?'• <span style="color:#ff8b96">Zombie</span>':''} ${c.virus?'• <span style="color:#a7f3d0">Viral</span>':''}</div>
    <div>Born: ${sp.totalBorn} • Deaths: ${sp.totalDeaths} • Best age: ${sp.bestAge.toFixed(1)} • Expansions: ${sp.expansions}</div>`;
  $story.textContent = `${sp.lore.title}\n\n${sp.lore.text}\n\nSaga:\n- ${sp.saga.slice(0,24).join('\n- ')}`;
}

/* ---------- Save/Load/Wipe ---------- */
function saveState(){
  try{
    const data={simTick,params,
      universes:Array.from(multiverse.universes.values()).map(u=>({
        id:u.id,seed:u.seed,size:u.size,
        creatures:u.creatures.map(c=>({x:c.x,y:c.y,vx:c.vx,vy:c.vy,ang:c.ang,energy:c.energy,age:c.age,speciesId:c.speciesId,cooldown:c.cooldown,zombie:c.zombie,virus:c.virus})),
        food=u.food,
        mecha=u.mecha,
        species:Array.from(u.species.values()).map(sp=>({id:sp.id,name:sp.name,parent:sp.parent,birthTick:sp.birthTick,totalBorn:sp.totalBorn,totalDeaths:sp.totalDeaths,bestAge:sp.bestAge,expansions:sp.expansions,genome:sp.genome,lore:sp.lore,saga:sp.saga}))
      })),
      edges:multiverse.edges.map(e=>({a:e.a,b:e.b})) };
    localStorage.setItem('multiverseSave', JSON.stringify(data)); logLine("💾 Saved.");
  }catch(e){ alert("Save failed: "+e); }
}
function loadState(){
  try{
    const s=localStorage.getItem('multiverseSave'); if(!s){ alert("No save found."); return; }
    const data=JSON.parse(s); simTick=data.simTick||0; multiverse.universes.clear(); multiverse.edges=[];
    for(const uo of data.universes){
      const u=new Universe(uo.id, uo.seed, uo.size);
      u.food=uo.food||[]; u.mecha=uo.mecha||[]; u.species.clear();
      for(const sp of uo.species){ u.species.set(sp.id,{...sp,cachedSprite:null,spriteScale:1}); }
      u.creatures=uo.creatures.map(c=>({...c,id:(u.id+"-"+Math.random()).slice(0,18)}));
      multiverse.universes.set(u.id,u);
    }
    for(const e of data.edges){ multiverse.connect(e.a,e.b); }
    multiverse.currentId=Math.min(...Array.from(multiverse.universes.keys()));
    centerView(); drawMini(); logLine("📂 Loaded.");
  }catch(e){ alert("Load failed: "+e); }
}
function wipeWorld(){
  localStorage.removeItem('multiverseSave');
  simTick=0; nextSpeciesId=1; eventsCount=0;
  multiverse.universes.clear(); multiverse.edges=[];
  multiverse.ensureUniverse(1); multiverse.ensureUniverse(2); multiverse.connect(1,2);
  multiverse.currentId=1; centerView(); drawMini();
  logLine("🧹 World wiped and rebooted.");
}

/* ---------- View & loop ---------- */
function centerView(){ const u=multiverse.currentUniverse(); if(!u) return; resizeCanvas(); view.x=u.size/2; view.y=u.size/2; view.z=Math.min(canvas.width,canvas.height)/(u.size*0.9)/DPR; }
let running=true; function togglePlay(){ running=!running; $fabPlay.textContent=running?"II":"▶︎"; }
$fabPlay.onclick=togglePlay; $fabCenter.onclick=()=>centerView(); $fabNew.onclick=()=>{ multiverse.addUniverseNearCurrent(); logLine("✦ New universe budded from current"); };
const FIXED_DT=0.08; let acc=0, last=performance.now()/1000;
function simulate(dt){ const active=new Set([multiverse.currentId]); for(const e of multiverse.edges){ if(e.a===multiverse.currentId) active.add(e.b); if(e.b===multiverse.currentId) active.add(e.a); }
  for(const id of active){ const u=multiverse.universes.get(id); if(u) u.step(dt); } simTick++; }
function render(){ const u=multiverse.currentUniverse(); if(u) drawUniverse(u); if($mapCard.classList.contains('show')) drawMini(); $tick.textContent="tick "+simTick; $pop.textContent="pop "+(u?u.creatures.length:0); $uni.textContent="universes "+multiverse.universes.size; $ev.textContent="events "+eventsCount; }
function stepOnce(){ simulate(FIXED_DT); render(); }
function frame(){ const now=performance.now()/1000; acc+=Math.min(0.25, now-last); last=now; if(running){ const step=FIXED_DT; while(acc>=step){ simulate(step); acc-=step; } } render(); requestAnimationFrame(frame); }

/* ---------- Kickoff ---------- */
multiverse.ensureUniverse(1); multiverse.ensureUniverse(2); multiverse.connect(1,2);
multiverse.currentId=1; centerView();
setTimeout(()=>{ $toast.classList.add('show'); setTimeout(()=>$toast.classList.remove('show'), 3000); }, 600);
requestAnimationFrame(frame);

})(); // IIFE
</script>
</body>
</html>