<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>∞ Multiverse Evolver — works on iPhone</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<style>
  :root{
    --bg:#0b0f16; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#7dd3fc;
    --accent2:#a78bfa; --danger:#f87171; --ok:#34d399; --gold:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh}
  header,footer{background:linear-gradient(180deg,#0f172a,transparent);padding:8px 10px}
  header{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  header .brand{font-weight:700;letter-spacing:.3px}
  header button, header .btn{border:1px solid #1f2937;background:#111827;color:#e5e7eb;border-radius:8px;padding:6px 10px;font-size:14px}
  header button:hover{background:#0f172a}
  header .pill{padding:6px 10px;border-radius:999px;border:1px solid #1f2937;background:#0b1220}
  #sim{position:relative;overflow:hidden;min-height:60vh}
  /* ✅ Make sure the canvas actually has layout size on iPhone */
  #c{position:absolute;inset:0;touch-action:none;display:block;width:100%;height:100%;
     background:radial-gradient(1200px 800px at 30% 30%, #0c1220 0%, #070b12 50%, #05070c 100%)}
  #hud{position:absolute;left:8px;top:8px;display:flex;gap:8px;flex-wrap:wrap}
  #hud .chip{background:#0b1220;border:1px solid #1e293b;border-radius:8px;padding:6px 8px;font-size:12px;color:var(--muted)}
  #right{position:absolute;right:10px;top:10px;width:min(360px,46vw);max-height:88vh;overflow:auto;background:#0b1220aa;border:1px solid #1e293b;border-radius:12px;padding:10px;backdrop-filter:blur(6px)}
  #right h3{margin:6px 0 4px 0;font-size:14px;color:#cbd5e1}
  #right .row{display:flex;align-items:center;gap:8px;margin:6px 0}
  #right input[type=range]{width:100%}
  #right .small{font-size:12px;color:var(--muted)}
  #right .divider{border-top:1px solid #1f2937;margin:8px 0}
  #miniWrap{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  canvas.mini{width:100%;height:120px;background:#0b1220;border:1px solid #1e293b;border-radius:8px}
  #log{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;white-space:pre-wrap;background:#0b1220;border:1px solid #1f2937;border-radius:8px;padding:8px;max-height:120px;overflow:auto}
  #inspect{background:#0b1220;border:1px solid #1f2937;border-radius:8px;padding:8px}
  footer{display:flex;justify-content:space-between;gap:8px;align-items:center}
  footer .group{display:flex;gap:6px;flex-wrap:wrap}
  footer button{border:1px solid #1f2937;background:#0b1220;color:#e5e7eb;border-radius:8px;padding:8px 10px}
  footer button.tiny{font-size:12px;padding:6px 8px}
  footer .speed{display:flex;gap:4px}
  .kbd{border:1px solid #1f2937;background:#111827;border-radius:6px;padding:1px 6px;font-size:12px;color:#cbd5e1}
  a{color:var(--accent)}
  @media (min-width:1000px){ #right{width:360px} header .brand{font-size:16px}}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="brand">∞ Multiverse Evolver</span>
    <span class="pill">Tap/Click creatures • Pinch to zoom • <span class="kbd">Space</span> play/pause</span>
    <button id="btnHelp">Help</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnWipe" title="Clear local save">Wipe</button>
    <span class="pill" id="statTick">tick 0</span>
    <span class="pill" id="statPop">pop 0</span>
    <span class="pill" id="statUni">universes 0</span>
  </header>

  <div id="sim">
    <canvas id="c"></canvas>
    <div id="hud"></div>
    <aside id="right">
      <h3>Parameters (live)</h3>
      <div class="row"><label>Mutation</label><input id="pmut" type="range" min="0" max="1" step="0.005" value="0.08"><span id="pmutv" class="small">0.08</span></div>
      <div class="row"><label>Food rate</label><input id="pfood" type="range" min="0" max="3" step="0.01" value="1.10"><span id="pfoodv" class="small">1.10</span></div>
      <div class="row"><label>Predation</label><input id="ppred" type="range" min="0" max="1" step="0.01" value="0.45"><span id="ppredv" class="small">0.45</span></div>
      <div class="row"><label>Migration</label><input id="pmig" type="range" min="0" max="1" step="0.01" value="0.25"><span id="pmigv" class="small">0.25</span></div>
      <div class="row"><label>Cap/pop</label><input id="pcap" type="range" min="40" max="400" step="10" value="220"><span id="pcapv" class="small">220</span></div>
      <div class="row"><label>Quality</label><input id="pqual" type="range" min="0.5" max="1.25" step="0.05" value="1.0"><span id="pqualv" class="small">1.00</span></div>

      <div class="divider"></div>
      <h3>Multiverse Map</h3>
      <div id="miniWrap">
        <canvas id="miniNet" class="mini" title="Tap a node to switch universes"></canvas>
        <canvas id="miniUni" class="mini" title="Local portals & density"></canvas>
      </div>

      <div class="divider"></div>
      <h3>Inspect</h3>
      <div id="inspect" class="small">Tap a creature to see genome, species, lineage & stats.</div>

      <div class="divider"></div>
      <h3>Chronicle</h3>
      <div id="log" class="small"></div>
    </aside>
  </div>

  <footer>
    <div class="group">
      <button id="btnPlay">▶︎ Play</button>
      <button id="btnPause">II Pause</button>
      <button id="btnStep" class="tiny">Step</button>
      <div class="speed">
        <button data-speed="0.25" class="tiny">0.25×</button>
        <button data-speed="1" class="tiny">1×</button>
        <button data-speed="2" class="tiny">2×</button>
        <button data-speed="4" class="tiny">4×</button>
        <button data-speed="8" class="tiny">8×</button>
        <button data-speed="16" class="tiny">16×</button>
        <button data-speed="32" class="tiny">32×</button>
      </div>
      <button id="btnNew" title="Grow a new connected universe">+ New Universe</button>
      <button id="btnCenter" class="tiny" title="Center view">Center</button>
    </div>
    <div class="group small">Fixed-step simulation (<span class="kbd">↑↓←→</span> pan, <span class="kbd">+</span>/<span class="kbd">-</span> zoom, <span class="kbd">D</span> step, <span class="kbd">H</span> help)</div>
  </footer>
</div>

<script>
/* ============================================================
   INFINITE MULTIVERSE EVOLVER — single-file
   Start-up robust & iPhone-friendly. Complex species shapes.
   ============================================================ */

(function(){
'use strict';

/* ---------- Canvas & sizing (robust for Safari) ---------- */
const DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
const canvas = document.getElementById('c');
let ctx;
try{ ctx = canvas.getContext('2d', {alpha:true}); }catch(_){ ctx = canvas.getContext('2d'); }

function cssSize(el){ const r=el.getBoundingClientRect(); return [Math.max(1,r.width), Math.max(1,r.height)]; }
function resizeCanvas(){
  // Use DOM size; if zero (Safari glitch), fallback to window size
  let [w,h] = cssSize(canvas);
  if(!w || !h){ w = window.innerWidth; h = Math.max(300, window.innerHeight*0.6); }
  const W = Math.floor(w * DPR), H = Math.floor(h * DPR);
  if(canvas.width!==W || canvas.height!==H){ canvas.width=W; canvas.height=H; }
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas, {passive:true});
let ro;
try{ ro = new ResizeObserver(resizeCanvas); ro.observe(canvas); }catch(_){ /* older Safari */ }

/* ---------- World <-> Screen ---------- */
let view = { x:0, y:0, z:1 };
function worldToScreen(x,y){ return [ (x - view.x)*view.z*DPR + canvas.width*0.5, (y - view.y)*view.z*DPR + canvas.height*0.5 ]; }
function screenToWorld(x,y){ return [ (x - canvas.width*0.5)/(view.z*DPR) + view.x, (y - canvas.height*0.5)/(view.z*DPR) + view.y ]; }

/* ---------- PRNG ---------- */
const TAU = Math.PI*2;
function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,61); return ((t^t>>>14)>>>0)/4294967296; } }
function rndRange(r,a,b){ return a + (b-a)*r(); }
function randInt(r,a,b){ return (rndRange(r,a,b+1))|0; }
function pick(r,arr){ return arr[(arr.length*r())|0]; }

/* ---------- Names ---------- */
const NAME_A = ["Auro","Cryo","Nocto","Sapro","Zygo","Luma","Chloro","Myco","Aether","Veloci","Tetra","Hexa","Quasi","Nebulo","Xeno","Paleo","Fracto","Spira","Plasma","Ortho","Iso","Aniso","Glacio","Pyro","Hydro"];
const NAME_B = ["phyllum","drome","phyte","morph","zoon","myra","cyst","pod","ther","carid","lith","bion","sema","tode","brach","forma","taxis","ceps","vore","meleon","plex","soma","gaster","arach","gryph"];
function speciesName(r){ return pick(r,NAME_A)+pick(r,NAME_B); }

/* ---------- Input ---------- */
let dragging=false, lastX=0,lastY=0, pinch=false, pinchDist=0, pinchStartZ=1;
canvas.addEventListener('mousedown',e=>{ dragging=true; [lastX,lastY]=[e.clientX,e.clientY]; });
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  view.x -= dx/(view.z*DPR); view.y -= dy/(view.z*DPR);
  [lastX,lastY]=[e.clientX,e.clientY];
});
canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const factor = (Math.sign(e.deltaY)>0)? 1/1.1 : 1.1;
  const [wx,wy] = screenToWorld(e.clientX*DPR, e.clientY*DPR);
  view.z = clamp(view.z*factor, 0.25, 5);
  const [wx2,wy2] = screenToWorld(e.clientX*DPR, e.clientY*DPR);
  view.x += (wx - wx2); view.y += (wy - wy2);
},{passive:false});

let lastTap=0;
canvas.addEventListener('touchstart',e=>{
  if(e.touches.length===1){
    const t=e.touches[0]; dragging=true; [lastX,lastY]=[t.clientX,t.clientY];
    const now=performance.now(); if(now-lastTap<300){ togglePlay(); } lastTap=now;
  }else if(e.touches.length===2){
    pinch=true; dragging=false;
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    pinchDist=Math.hypot(dx,dy); pinchStartZ=view.z;
  }
},{passive:true});
canvas.addEventListener('touchmove',e=>{
  if(pinch && e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.hypot(dx,dy);
    const f = d/pinchDist;
    view.z = clamp(pinchStartZ*f, 0.25, 5);
  }else if(dragging && e.touches.length===1){
    const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY;
    view.x -= dx/(view.z*DPR); view.y -= dy/(view.z*DPR);
    [lastX,lastY]=[t.clientX,t.clientY];
  }
},{passive:true});
window.addEventListener('touchend',()=>{ pinch=false; dragging=false; });
window.addEventListener('keydown',e=>{
  if(e.key===' '){ e.preventDefault(); togglePlay(); }
  if(e.key==='d'||e.key==='D'){ stepOnce(); }
  if(e.key==='+'){ view.z=clamp(view.z*1.1,0.25,5); }
  if(e.key==='-'){ view.z=clamp(view.z/1.1,0.25,5); }
  if(e.key==='ArrowUp'){ view.y -= 40/(view.z); }
  if(e.key==='ArrowDown'){ view.y += 40/(view.z); }
  if(e.key==='ArrowLeft'){ view.x -= 40/(view.z); }
  if(e.key==='ArrowRight'){ view.x += 40/(view.z); }
  if(e.key==='h'||e.key==='H'){ showHelp(); }
});
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

/* ---------- UI wiring ---------- */
const qs = s=>document.querySelector(s);
const $pmut=qs('#pmut'),$pfood=qs('#pfood'),$ppred=qs('#ppred'),$pmig=qs('#pmig'),$pcap=qs('#pcap'),$pqual=qs('#pqual');
const $pmutv=qs('#pmutv'),$pfoodv=qs('#pfoodv'),$ppredv=qs('#ppredv'),$pmigv=qs('#pmigv'),$pcapv=qs('#pcapv'),$pqualv=qs('#pqualv');
[$pmut,$pfood,$ppred,$pmig,$pcap,$pqual].forEach(inp=>{
  inp.addEventListener('input',()=>{
    params.mutation=+$pmut.value; $pmutv.textContent=params.mutation.toFixed(2);
    params.foodRate=+$pfood.value; $pfoodv.textContent=params.foodRate.toFixed(2);
    params.predation=+$ppred.value; $ppredv.textContent=params.predation.toFixed(2);
    params.migration=+$pmig.value; $pmigv.textContent=params.migration.toFixed(2);
    params.cap=+$pcap.value|0; $pcapv.textContent=params.cap;
    params.quality=+$pqual.value; $pqualv.textContent=params.quality.toFixed(2);
    // invalidate sprites if quality changed
    for(const u of multiverse.universes.values()) for(const sp of u.species.values()) sp.cachedSprite=null;
  });
});
qs('#btnPlay').onclick=()=>{ running=true; updateButtons(); };
qs('#btnPause').onclick=()=>{ running=false; updateButtons(); };
qs('#btnStep').onclick=()=>stepOnce();
qs('#btnCenter').onclick=()=>centerView();
qs('#btnNew').onclick=()=>{ multiverse.addUniverseNearCurrent(); drawMini(); logLine("✦ New universe budded from current"); };
document.querySelectorAll('footer .speed button[data-speed]').forEach(b=> b.addEventListener('click',()=>{ simSpeed=+b.dataset.speed; }));
qs('#btnHelp').onclick=()=>showHelp();
qs('#btnSave').onclick=()=>saveState();
qs('#btnLoad').onclick=()=>loadState();
qs('#btnWipe').onclick=()=>{ localStorage.removeItem('multiverseSave'); logLine("Local save cleared."); };

const $tick=qs('#statTick'), $pop=qs('#statPop'), $uni=qs('#statUni');
const $log=qs('#log'), $inspect=qs('#inspect');
function logLine(s){ $log.textContent=(s+"\n"+$log.textContent).slice(0,4000); }
function showHelp(){ alert("Drag to pan • Pinch/scroll to zoom • Double-tap to play/pause\nTap a creature for genome & lineage.\nPortals link universes; species migrate & speciate.\nUse Save/Load to persist."); }

/* ---------- Params & fixed step ---------- */
const params = { mutation:+$pmut.value, foodRate:+$pfood.value, predation:+$ppred.value, migration:+$pmig.value, cap:+$pcap.value|0, quality:+$pqual.value };
const FIXED_DT=0.08; let simSpeed=1, running=true;
function togglePlay(){ running=!running; updateButtons(); }
function updateButtons(){ qs('#btnPlay').disabled=running; qs('#btnPause').disabled=!running; }

/* ---------- Genetics ---------- */
function randomGenome(r){
  const morph = randInt(r,0,4), hue=randInt(r,0,360), sat=rndRange(r,0.5,1), lum=rndRange(r,0.45,0.75);
  const size=rndRange(r,8,18), speed=rndRange(r,16,48), sense=rndRange(r,60,140);
  const dietR=r(); const diet=dietR<0.55?0:(dietR<0.8?2:1);
  const specVar=new Array(6).fill(0).map(()=>rndRange(r,0,1));
  return {morph,hue,sat,lum,size,speed,sense,diet,specVar};
}
function mutateGenome(p, r, rate){
  const g=JSON.parse(JSON.stringify(p));
  function j(v,a){ return v + (r()*2-1)*a*rate; }
  if(r()<rate*0.6) g.morph=(g.morph+(r()<0.5?-1:1)+5)%5;
  g.hue=(g.hue+randInt(r,-20,20)+360)%360;
  g.sat=clamp(j(g.sat,0.25),0.2,1); g.lum=clamp(j(g.lum,0.2),0.25,0.85);
  g.size=clamp(j(g.size,6),6,28); g.speed=clamp(j(g.speed,18),8,70); g.sense=clamp(j(g.sense,50),30,220);
  if(r()<rate*0.5) g.diet=randInt(r,0,2);
  for(let i=0;i<g.specVar.length;i++) g.specVar[i]=clamp(j(g.specVar[i],0.7),0,1);
  return g;
}

/* ---------- Species & creatures ---------- */
let nextSpeciesId=1, simTick=0;
function makeSpecies(r, parentId=null, parentGenome=null){
  const genome=parentGenome?mutateGenome(parentGenome,r,params.mutation*0.8):randomGenome(r);
  const id=nextSpeciesId++, name=speciesName(r), color=`hsl(${genome.hue}deg 80% 55%)`;
  return {id,name,genome,parent:parentId,birthTick:simTick,totalBorn:0,totalDeaths:0,bestAge:0,expansions:0,color,cachedSprite:null,spriteScale:1};
}
function makeCreature(u, sp, x, y){
  const g=sp.genome, ang=u.rng()*TAU;
  return {x,y,vx:Math.cos(ang)*0.1,vy:Math.sin(ang)*0.1,ang,energy:60+u.rng()*40,age:0,speciesId:sp.id,target:null,cooldown:0,blink:0,id:(u.id+"-"+Math.random()).slice(0,18)};
}
function makeFood(u){ return {x:rndRange(u.rng,0,u.size),y:rndRange(u.rng,0,u.size),v:rndRange(u.rng,4,10)}; }

/* ---------- Universe ---------- */
class Universe{
  constructor(id, seed, size=1200){
    this.id=id; this.size=size; this.seed=seed; this.rng=mulberry32(seed);
    this.creatures=[]; this.food=[]; this.species=new Map(); this.holes=[];
    this.gridSize=60; this.grid=new Map(); this.chronicle=[];
    this.spawnInitial(); this.createBlackHoles();
  }
  log(s){ this.chronicle.unshift({t:simTick,s}); if(this===multiverse.currentUniverse()) logLine("U"+this.id+": "+s); if(this.chronicle.length>80) this.chronicle.pop(); }
  spawnInitial(){
    for(let s=0;s<3;s++){
      const sp=makeSpecies(this.rng);
      this.species.set(sp.id,sp);
      for(let i=0;i<24;i++){
        const x=rndRange(this.rng,200,this.size-200), y=rndRange(this.rng,200,this.size-200);
        const c=makeCreature(this,sp,x,y); this.creatures.push(c); sp.totalBorn++;
      }
    }
    for(let i=0;i<220;i++) this.food.push(makeFood(this));
    this.log(`Universe ${this.id} awakens with ${this.creatures.length} lifeforms.`);
  }
  createBlackHoles(){
    const n=randInt(this.rng,2,3); this.holes=[];
    for(let i=0;i<n;i++){
      const pos=[rndRange(this.rng,120,this.size-120), this.rng()<0.5?rndRange(this.rng,40,100):rndRange(this.rng,this.size-100,this.size-40)];
      if(this.rng()<0.5) pos.reverse();
      this.holes.push({x:pos[0],y:pos[1],r:40,angle:this.rng()*TAU,link:null});
    }
  }
  clearGrid(){ this.grid.clear(); }
  cellKey(x,y){ return ((x/this.gridSize)|0)+"," + ((y/this.gridSize)|0); }
  addToGrid(c){ const k=this.cellKey(c.x,c.y); let a=this.grid.get(k); if(!a){a=[]; this.grid.set(k,a);} a.push(c); }
  neighbors(x,y,rad){
    const r=(rad/this.gridSize|0)+1, cx=(x/this.gridSize|0), cy=(y/this.gridSize|0), out=[];
    for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++){ const a=this.grid.get((cx+dx)+","+(cy+dy)); if(a) out.push(...a); }
    return out;
  }
  step(dt){
    // Spawn food according to demand
    const want=Math.max(60, params.cap*0.8);
    const deficit=Math.max(0, want-(this.food.length*2));
    for(let i=0;i<((params.foodRate*deficit*0.02)|0);i++) this.food.push(makeFood(this));

    this.clearGrid(); for(const c of this.creatures) this.addToGrid(c);

    const removal=[];
    for(const c of this.creatures){
      const sp=this.species.get(c.speciesId); if(!sp){ removal.push(c); continue; }
      const g=sp.genome;
      c.age+=dt; c.energy-=0.03+g.speed*0.0002+g.size*0.0004;
      if(c.cooldown>0) c.cooldown-=dt; if(c.blink>0) c.blink-=dt;

      // Sense
      let tx=null,ty=null,tDist=1e9,target=null,targetType=null;
      const neigh=this.neighbors(c.x,c.y,g.sense);
      if(g.diet===0||g.diet===2){
        // naive scan (OK at this scale)
        for(const f of this.food){ const dx=f.x-c.x,dy=f.y-c.y,d2=dx*dx+dy*dy; if(d2<tDist && d2<g.sense*g.sense){ tDist=d2; tx=f.x; ty=f.y; target=f; targetType='food'; } }
      }
      if(g.diet===1||g.diet===2){
        for(const o of neigh){ if(o===c) continue; const osp=this.species.get(o.speciesId);
          if(osp && osp.genome.size < g.size*0.95){ const dx=o.x-c.x, dy=o.y-c.y, d2=dx*dx+dy*dy; if(d2<tDist && d2<g.sense*g.sense){ tDist=d2; tx=o.x; ty=o.y; target=o; targetType='prey'; } }
        }
      }

      // Steering
      let ax=0,ay=0;
      const r1=this.rng(); c.ang += (r1-0.5)*0.2;
      ax += Math.cos(c.ang)*0.5; ay += Math.sin(c.ang)*0.5;
      if(tx!=null){ const dx=tx-c.x, dy=ty-c.y, d=Math.hypot(dx,dy)+1e-6; ax += dx/d*1.2; ay += dy/d*1.2; }
      const m=100; if(c.x<m) ax+=0.6; if(c.y<m) ay+=0.6; if(c.x>this.size-m) ax-=0.6; if(c.y>this.size-m) ay-=0.6;

      // Velocity & position
      c.vx=clamp(c.vx+ax*dt,-2,2); c.vy=clamp(c.vy+ay*dt,-2,2);
      const spd=g.speed*0.02, vlen=Math.hypot(c.vx,c.vy); if(vlen>0){ c.vx=c.vx/vlen*spd; c.vy=c.vy/vlen*spd; }
      c.x+=c.vx; c.y+=c.vy;

      // Interactions
      if(targetType==='food'){
        if(Math.hypot(target.x-c.x,target.y-c.y)<g.size*0.8){
          c.energy += target.v; this.food.splice(this.food.indexOf(target),1); c.blink=0.2;
        }
      }else if(targetType==='prey' && Math.random()<params.predation){
        if(Math.hypot(target.x-c.x,target.y-c.y)<(g.size*0.6)){
          const idx=this.creatures.indexOf(target); if(idx>=0){ this.creatures.splice(idx,1); const tsp=this.species.get(target.speciesId); if(tsp) tsp.totalDeaths++; c.energy+=40; c.blink=0.25; }
        }
      }

      // Reproduction
      if(c.energy>120 && c.cooldown<=0 && this.creatures.length<params.cap){
        c.energy*=0.5; c.cooldown=2.2;
        let childSpecies=sp;
        if(Math.random()<params.mutation*0.25){
          const newSp=makeSpecies(this.rng, sp.id, sp.genome);
          this.species.set(newSp.id,newSp); this.log(`Speciation: ${sp.name} → ${newSp.name}`); childSpecies=newSp;
        }
        const cc=makeCreature(this,childSpecies,c.x+(Math.random()*8-4),c.y+(Math.random()*8-4));
        if(Math.random()<params.mutation*0.6){ childSpecies.genome=mutateGenome(childSpecies.genome,this.rng,params.mutation*0.5); childSpecies.cachedSprite=null; }
        this.creatures.push(cc); childSpecies.totalBorn++;
      }

      // Death
      if(c.energy<=0 || c.age>1800) removal.push(c);

      // Migration
      if(Math.random()<params.migration*0.02){
        for(const h of this.holes){
          if(Math.hypot(c.x-h.x,c.y-h.y)<h.r*0.9 && h.link){ multiverse.migrate(c,this,h); break; }
        }
      }
    }
    for(const c of removal){ const sp=this.species.get(c.speciesId); if(sp) sp.totalDeaths++; const i=this.creatures.indexOf(c); if(i>=0) this.creatures.splice(i,1); }

    // Soft cap
    if(this.creatures.length>params.cap*1.2){
      this.creatures.sort((a,b)=>(a.energy+a.age*0.2)-(b.energy+b.age*0.2));
      const kill=(this.creatures.length-params.cap)|0;
      for(let i=0;i<kill;i++){ const c=this.creatures[i]; const sp=this.species.get(c.speciesId); if(sp) sp.totalDeaths++; }
      this.creatures.splice(0,kill); this.log(`Culled ${kill} to stabilize.`);
    }

    // Track best ages
    for(const sp of this.species.values()){
      let best=0; for(const c of this.creatures){ if(c.speciesId===sp.id && c.age>best) best=c.age; } sp.bestAge=Math.max(sp.bestAge,best);
    }

    // Self-heal if population wiped (rare)
    if(this.creatures.length===0){
      const sp=makeSpecies(this.rng); this.species.set(sp.id,sp);
      for(let i=0;i<12;i++){ const x=rndRange(this.rng,200,this.size-200), y=rndRange(this.rng,200,this.size-200); this.creatures.push(makeCreature(this,sp,x,y)); }
      this.log("Biosphere rebooted.");
    }
  }
}

/* ---------- Multiverse ---------- */
const multiverse={
  universes:new Map(), edges:[], currentId:1, rng:mulberry32((Date.now()*2654435761)>>>0),
  currentUniverse(){ return this.universes.get(this.currentId); },
  ensureUniverse(id){ if(this.universes.has(id)) return this.universes.get(id); const u=new Universe(id, randInt(this.rng,1,2**31-1)); this.universes.set(id,u); return u; },
  connect(a,b){
    const ua=this.ensureUniverse(a), ub=this.ensureUniverse(b);
    const ha=ua.holes.find(h=>!h.link)||ua.holes[0], hb=ub.holes.find(h=>!h.link)||ub.holes[0];
    ha.link={universe:b,hole:hb}; hb.link={universe:a,hole:ha}; this.edges.push({a,b,aHole:ha,bHole:hb});
    ua.log(`Wormhole opened to U${b}.`); ub.log(`Wormhole opened to U${a}.`);
  },
  addUniverseNearCurrent(){
    const newId=this.universes.size? Math.max(...this.universes.keys())+1:1;
    const u=this.ensureUniverse(newId);
    if(this.universes.size===1){ this.currentId=newId; return; }
    this.connect(this.currentId,newId);
  },
  migrate(creature, fromU, holeA){
    const link=holeA.link; if(!link) return;
    const toU=this.ensureUniverse(link.universe);
    // 🔧 Bring species definition along if missing (fixes crash)
    if(!toU.species.has(creature.speciesId)){
      const spFrom=fromU.species.get(creature.speciesId);
      if(spFrom){ toU.species.set(spFrom.id, {...JSON.parse(JSON.stringify(spFrom)), cachedSprite:null, spriteScale:1}); }
    }
    const idx=fromU.creatures.indexOf(creature); if(idx>=0) fromU.creatures.splice(idx,1);
    const toHole=link.hole;
    creature.x=toHole.x+(Math.random()*6-3); creature.y=toHole.y+(Math.random()*6-3);
    creature.vx*=0.5; creature.vy*=0.5; creature.blink=0.3;
    toU.creatures.push(creature);
    const sp=toU.species.get(creature.speciesId); if(sp) sp.expansions++;
    toU.log(`Migration: one ${sp?sp.name:"organism"} arrived.`);
  }
};
// Bootstrap
multiverse.ensureUniverse(1); multiverse.ensureUniverse(2); multiverse.connect(1,2); multiverse.currentId=1;

/* ---------- Species sprites (complex silhouettes) ---------- */
function getSpeciesSprite(u, sp){
  if(!sp) return null;
  if(sp.cachedSprite && sp.spriteScale===params.quality) return sp.cachedSprite;
  const g=sp.genome, scale=g.size*params.quality, sz=Math.max(32, Math.min(196, (scale*7)|0));
  const oc=document.createElement('canvas'); oc.width=oc.height=sz; const cx=oc.getContext('2d');
  cx.translate(sz/2, sz/2); cx.scale(scale/18, scale/18);
  const fill=`hsl(${g.hue}deg ${Math.round(60+g.sat*35)}% ${Math.round(45+g.lum*30)}%)`;
  const stroke=`hsl(${(g.hue+30)%360}deg 50% 30%)`; cx.shadowColor=`hsl(${g.hue}deg 100% 50% / 0.25)`; cx.shadowBlur=6;
  switch(g.morph){ case 0: drawRadiate(cx,g,fill,stroke); break; case 1: drawBilateral(cx,g,fill,stroke); break; case 2: drawOrbital(cx,g,fill,stroke); break; case 3: drawSpiralShell(cx,g,fill,stroke); break; case 4: drawLeafFrond(cx,g,fill,stroke); break; }
  // tiny sensor eye
  cx.save(); cx.rotate((g.specVar[4]-0.5)*0.8); cx.fillStyle='white'; cx.beginPath(); cx.ellipse(4,-2,2.5,1.6,0,0,TAU); cx.fill();
  cx.fillStyle='black'; cx.beginPath(); cx.ellipse(4,-2,1,0.7,0,0,TAU); cx.fill(); cx.restore();
  sp.cachedSprite=oc; sp.spriteScale=params.quality; return oc;
}
function superPath(cx,m,n1,n2,n3,steps,scale=12,jitter=0){ cx.beginPath(); for(let i=0;i<=steps;i++){ const phi=TAU*i/steps,a=1,b=1; const t1=Math.pow(Math.abs(Math.cos(m*phi/4)/a),n2); const t2=Math.pow(Math.abs(Math.sin(m*phi/4)/b),n3); let r=Math.pow(t1+t2,-1/n1); if(!isFinite(r)) r=0; if(jitter) r*=1+(Math.sin(phi*5+(steps%13))*jitter); const x=r*Math.cos(phi)*scale,y=r*Math.sin(phi)*scale; i?cx.lineTo(x,y):cx.moveTo(x,y);} cx.closePath(); }
function drawRadiate(cx,g,fill,stroke){ const m=5+(g.specVar[0]*5|0); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=1.8; superPath(cx,m,0.6+g.specVar[1]*1.4,5,12,240,16,0.04*g.specVar[2]); cx.fill(); cx.stroke(); cx.save(); cx.globalAlpha=0.25; cx.fillStyle=`hsl(${(g.hue+310)%360}deg 80% 70%)`; superPath(cx,m+1,0.8,8,4,200,10,0); cx.fill(); cx.restore(); cx.strokeStyle=`hsl(${g.hue}deg 70% 60% / 0.6)`; cx.lineWidth=1.2; const arms=6+(g.specVar[3]*6|0); for(let i=0;i<arms;i++){ const a=TAU*i/arms+g.specVar[4]*0.7; cx.beginPath(); cx.moveTo(Math.cos(a)*6,Math.sin(a)*6); const len=10+g.specVar[5]*16; for(let k=1;k<=4;k++){ const t=k/4; const x=Math.cos(a)*(6+t*len)+Math.sin(a*3+t*2)*1.5; const y=Math.sin(a)*(6+t*len)+Math.cos(a*4+t*3)*1.5; cx.lineTo(x,y);} cx.stroke(); } }
function drawBilateral(cx,g,fill,stroke){ cx.save(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=2; cx.beginPath(); cx.moveTo(10,0); cx.bezierCurveTo(6,-8,-4,-10,-10,0); cx.bezierCurveTo(-4,10,6,8,10,0); cx.closePath(); cx.fill(); cx.stroke(); const legs=3+(g.specVar[0]*5|0); cx.strokeStyle=`hsl(${(g.hue+40)%360}deg 50% 55%)`; cx.lineWidth=1.2; for(let i=0;i<legs;i++){ const y=-6+i*(12/(legs-1)); cx.beginPath(); cx.moveTo(-4,y); cx.quadraticCurveTo(-12,y-2,-14,y+(i%2?3:-3)); cx.moveTo(4,y); cx.quadraticCurveTo(12,y+2,14,y+(i%2?-3:3)); cx.stroke(); } cx.beginPath(); cx.moveTo(6,-3); cx.quadraticCurveTo(12,-10,14,-12); cx.moveTo(6,3); cx.quadraticCurveTo(12,10,14,12); cx.stroke(); cx.globalAlpha=0.3; cx.fillStyle='white'; for(let i=0;i<5;i++){ cx.fillRect(-2+i*2-5,-8,1,16);} cx.restore(); }
function drawOrbital(cx,g,fill,stroke){ cx.save(); const ring=10+g.specVar[0]*8; cx.strokeStyle=`hsl(${g.hue}deg 70% 60% / 0.8)`; cx.lineWidth=1.4; cx.beginPath(); cx.ellipse(0,0,ring,ring*0.6,g.specVar[1]*0.9,0,TAU); cx.stroke(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=1.8; cx.beginPath(); cx.arc(0,0,7+g.specVar[2]*4,0,TAU); cx.fill(); cx.stroke(); const pods=3+(g.specVar[3]*5|0); cx.fillStyle=`hsl(${(g.hue+260)%360}deg 70% 70%)`; for(let i=0;i<pods;i++){ const a=TAU*i/pods+g.specVar[4]*1.2; cx.beginPath(); cx.arc(Math.cos(a)*ring,Math.sin(a)*ring*0.6,2+g.specVar[5]*2,0,TAU); cx.fill(); } cx.restore(); }
function drawSpiralShell(cx,g,fill,stroke){ cx.save(); const turns=2.2+g.specVar[0]*2; cx.strokeStyle=stroke; cx.lineWidth=1.6; cx.beginPath(); for(let t=0;t<1;t+=1/140){ const a=t*TAU*turns, r=3+12*t, x=r*Math.cos(a), y=r*Math.sin(a); t?cx.lineTo(x,y):cx.moveTo(x,y);} cx.stroke(); cx.strokeStyle=`hsl(${(g.hue+20)%360}deg 40% 55% / 0.7)`; cx.lineWidth=1; for(let i=0;i<11;i++){ const t=i/10,a=t*TAU*turns,r=3+12*t,x=r*Math.cos(a),y=r*Math.sin(a),nx=Math.cos(a+Math.PI/2),ny=Math.sin(a+Math.PI/2); cx.beginPath(); cx.moveTo(x,y); cx.lineTo(x+nx*3,y+ny*3); cx.stroke(); } cx.globalAlpha=0.35; cx.fillStyle=fill; cx.beginPath(); cx.arc(0,0,12,0,TAU); cx.fill(); cx.restore(); }
function drawLeafFrond(cx,g,fill,stroke){ cx.save(); cx.fillStyle=fill; cx.strokeStyle=stroke; cx.lineWidth=1.4; cx.beginPath(); cx.moveTo(-12,0); cx.quadraticCurveTo(0,-10,12,0); cx.quadraticCurveTo(0,10,-12,0); cx.closePath(); cx.fill(); cx.stroke(); cx.strokeStyle=`hsl(${(g.hue+90)%360}deg 40% 60%)`; cx.beginPath(); cx.moveTo(-10,0); cx.lineTo(10,0); cx.stroke(); cx.globalAlpha=0.8; cx.lineWidth=1; for(let i=0;i<6;i++){ const t=-8+i*3.2; cx.beginPath(); cx.moveTo(t,0); cx.quadraticCurveTo(t+2,-4,t+4,-6); cx.stroke(); cx.beginPath(); cx.moveTo(t,0); cx.quadraticCurveTo(t+2,4,t+4,6); cx.stroke(); } cx.restore(); }

/* ---------- Rendering ---------- */
function drawUniverse(u){
  ctx.fillStyle='rgba(8,12,18,0.95)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(canvas.width/2,canvas.height/2); ctx.scale(view.z*DPR,view.z*DPR); ctx.translate(-view.x,-view.y);
  ctx.strokeStyle='rgba(125,211,252,0.08)'; ctx.lineWidth=2/view.z/DPR; ctx.strokeRect(0,0,u.size,u.size);
  // Food
  ctx.fillStyle='rgba(125,255,160,0.8)'; for(const f of u.food){ ctx.beginPath(); ctx.arc(f.x,f.y,1.5+f.v*0.05,0,TAU); ctx.fill(); }
  // Portals
  for(const h of u.holes){
    const grad=ctx.createRadialGradient(h.x,h.y,4,h.x,h.y,h.r);
    grad.addColorStop(0,'rgba(167,139,250,0.9)'); grad.addColorStop(0.5,'rgba(56,189,248,0.4)'); grad.addColorStop(1,'rgba(2,6,23,0.2)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,TAU); ctx.fill();
    ctx.strokeStyle='rgba(125,211,252,0.5)'; ctx.lineWidth=1.5/view.z/DPR; ctx.beginPath();
    for(let t=0;t<TAU;t+=TAU/64){ const r=h.r*0.7+Math.sin(t*4+simTick*0.05)*2; const x=h.x+Math.cos(t+h.angle)*r, y=h.y+Math.sin(t+h.angle)*r; t===0?ctx.moveTo(x,y):ctx.lineTo(x,y); }
    ctx.closePath(); ctx.stroke(); if(h.link){ ctx.fillStyle='rgba(250,204,21,0.8)'; ctx.fillRect(h.x-2,h.y-2,4,4); }
  }
  // Creatures
  for(const c of u.creatures){
    const sp=u.species.get(c.speciesId); if(!sp) continue;
    const sprite=getSpeciesSprite(u,sp); if(!sprite) continue;
    ctx.save(); ctx.translate(c.x,c.y); const rot=Math.atan2(c.vy,c.vx); ctx.rotate(rot);
    ctx.globalAlpha=0.9 + Math.sin((c.age*0.5 + c.x*0.01))*0.1; if(c.blink>0) ctx.globalAlpha=1;
    const s=1.0; ctx.drawImage(sprite, -sprite.width*0.02*s, -sprite.height*0.02*s, sprite.width*0.04*s, sprite.height*0.04*s);
    ctx.restore();
  }
  if(selected && selected.u===u && selected.c){
    ctx.save(); ctx.strokeStyle='rgba(251,191,36,0.9)'; ctx.lineWidth=2/view.z/DPR; ctx.beginPath(); ctx.arc(selected.c.x,selected.c.y,14,0,TAU); ctx.stroke(); ctx.restore();
  }
  ctx.restore();
}

/* ---------- Mini maps ---------- */
const miniNet=qs('#miniNet'), miniUni=qs('#miniUni');
const mNet=miniNet.getContext('2d'), mUni=miniUni.getContext('2d');
function resizeMini(){ miniNet.width=miniNet.clientWidth*DPR; miniNet.height=miniNet.clientHeight*DPR; miniUni.width=miniUni.clientWidth*DPR; miniUni.height=miniUni.clientHeight*DPR; }
new ResizeObserver(()=>resizeMini()).observe(miniNet); new ResizeObserver(()=>resizeMini()).observe(miniUni);
function drawMini(){
  mNet.clearRect(0,0,miniNet.width,miniNet.height);
  const nodes=Array.from(multiverse.universes.keys()); if(!nodes.length) return;
  const w=miniNet.width,h=miniNet.height,r=Math.min(w,h)*0.35; const pos=new Map();
  nodes.forEach((id,i)=>{ const a=TAU*i/nodes.length; pos.set(id,[w/2+Math.cos(a)*r,h/2+Math.sin(a)*r]); });
  mNet.strokeStyle='rgba(125,211,252,0.5)'; mNet.lineWidth=2;
  for(const e of multiverse.edges){ const [ax,ay]=pos.get(e.a), [bx,by]=pos.get(e.b); mNet.beginPath(); mNet.moveTo(ax,ay); mNet.lineTo(bx,by); mNet.stroke(); }
  for(const id of nodes){ const [x,y]=pos.get(id); const u=multiverse.universes.get(id), pop=u.creatures.length;
    mNet.fillStyle=id===multiverse.currentId?'#fbbf24':'#7dd3fc'; mNet.beginPath(); mNet.arc(x,y,8+Math.min(8,pop/80),0,TAU); mNet.fill();
    mNet.fillStyle='#cbd5e1'; mNet.font=`${12*DPR}px system-ui`; mNet.textAlign='center'; mNet.fillText(id,x,y-14);
  }
  miniNet.onclick=(e)=>{ const r=miniNet.getBoundingClientRect(); const x=(e.clientX-r.left)*DPR, y=(e.clientY-r.top)*DPR; for(const [id,p] of pos){ if(Math.hypot(x-p[0],y-p[1])<14*DPR){ multiverse.currentId=id; centerView(); break; } } };
  // Local
  mUni.clearRect(0,0,miniUni.width,miniUni.height); const u=multiverse.currentUniverse(); if(!u) return;
  const sc=Math.min(miniUni.width,miniUni.height)/(u.size*1.1), tx=x=>x*sc+miniUni.width*0.05, ty=y=>y*sc+miniUni.height*0.05;
  mUni.strokeStyle='rgba(148,163,184,0.4)'; mUni.strokeRect(tx(0),ty(0),u.size*sc,u.size*sc);
  mUni.fillStyle='rgba(34,197,94,0.6)'; for(const f of u.food){ mUni.fillRect(tx(f.x),ty(f.y),1,1); }
  mUni.fillStyle='rgba(251,191,36,0.9)'; for(const h of u.holes){ mUni.beginPath(); mUni.arc(tx(h.x),ty(h.y),6,0,TAU); mUni.fill(); }
}

/* ---------- Selection ---------- */
let selected=null;
canvas.addEventListener('click', e=>{
  const r=canvas.getBoundingClientRect(); const [wx,wy]=screenToWorld((e.clientX-r.left)*DPR,(e.clientY-r.top)*DPR);
  const u=multiverse.currentUniverse(); let best=null, bd=20; for(const c of u.creatures){ const d=Math.hypot(c.x-wx,c.y-wy); if(d<bd){ bd=d; best=c; } }
  if(best){ selected={u,c:best}; showInspect(best,u); }
});
function showInspect(c,u){
  const sp=u.species.get(c.speciesId), parent=sp.parent?u.species.get(sp.parent):null, t=sp.genome;
  $inspect.innerHTML=`<div><b>${sp.name}</b> <span class="small">[Species #${sp.id}]</span></div>
  <div class="small">Parent: ${parent? parent.name+" (#"+parent.id+")":"— root"}</div>
  <div class="small">Diet: ${["Herbivore","Predator","Omnivore"][t.diet]}</div>
  <div class="small">Morph: ${["Radiate","Bilateral","Orbital","Shell","Frond"][t.morph]}</div>
  <div class="small">Hue/Sat/Lum: ${t.hue} / ${t.sat.toFixed(2)} / ${t.lum.toFixed(2)}</div>
  <div class="small">Size: ${t.size.toFixed(1)}  Speed: ${t.speed.toFixed(1)}  Sense: ${t.sense.toFixed(0)}</div>
  <div class="small">Creature age: ${c.age.toFixed(1)}  energy: ${c.energy.toFixed(0)}</div>
  <div class="small">Born: ${sp.totalBorn} • Deaths: ${sp.totalDeaths} • Best age: ${sp.bestAge.toFixed(1)} • Expansions: ${sp.expansions}</div>`;
}

/* ---------- Save/Load ---------- */
function saveState(){
  try{
    const data={simTick,params,
      universes:Array.from(multiverse.universes.values()).map(u=>({
        id:u.id,seed:u.seed,size:u.size,
        creatures:u.creatures.map(c=>({x:c.x,y:c.y,vx:c.vx,vy:c.vy,ang:c.ang,energy:c.energy,age:c.age,speciesId:c.speciesId,cooldown:c.cooldown})),
        food:u.food,
        species:Array.from(u.species.values()).map(sp=>({id:sp.id,name:sp.name,parent:sp.parent,birthTick:sp.birthTick,totalBorn:sp.totalBorn,totalDeaths:sp.totalDeaths,bestAge:sp.bestAge,expansions:sp.expansions,genome:sp.genome}))
      })),
      edges:multiverse.edges.map(e=>({a:e.a,b:e.b})) };
    localStorage.setItem('multiverseSave',JSON.stringify(data)); logLine("Saved.");
  }catch(e){ alert("Save failed: "+e); }
}
function loadState(){
  try{
    const s=localStorage.getItem('multiverseSave'); if(!s){ alert("No save found."); return; }
    const data=JSON.parse(s); simTick=data.simTick||0; multiverse.universes.clear(); multiverse.edges=[];
    for(const uo of data.universes){
      const u=new Universe(uo.id, uo.seed, uo.size);
      u.food=uo.food||[]; u.species.clear();
      for(const sp of uo.species){ u.species.set(sp.id,{...sp,cachedSprite:null,spriteScale:1}); }
      u.creatures=uo.creatures.map(c=>({...c,id:(u.id+"-"+Math.random()).slice(0,18)})); multiverse.universes.set(u.id,u);
    }
    for(const e of data.edges){ multiverse.connect(e.a,e.b); }
    multiverse.currentId=Math.min(...Array.from(multiverse.universes.keys())); drawMini(); logLine("Loaded.");
  }catch(e){ alert("Load failed: "+e); }
}

/* ---------- View helpers ---------- */
function centerView(){ const u=multiverse.currentUniverse(); if(!u) return; resizeCanvas(); view.x=u.size/2; view.y=u.size/2; view.z=Math.min(canvas.width,canvas.height)/(u.size*0.9)/DPR; }

/* ---------- Main loop ---------- */
let acc=0, last=performance.now()/1000;
function simulate(dt){
  const active=new Set([multiverse.currentId]); for(const e of multiverse.edges){ if(e.a===multiverse.currentId) active.add(e.b); if(e.b===multiverse.currentId) active.add(e.a); }
  for(const id of active){ const u=multiverse.universes.get(id); if(u) u.step(dt); }
  simTick++;
}
function render(){
  resizeCanvas(); resizeMini();
  const u=multiverse.currentUniverse(); if(u) drawUniverse(u);
  drawMini();
  $tick.textContent="tick "+simTick; $pop.textContent="pop "+(u?u.creatures.length:0); $uni.textContent="universes "+multiverse.universes.size;
}
function frame(){
  try{
    const now=performance.now()/1000; acc += Math.min(0.25, now-last); last=now;
    if(running){ const step = FIXED_DT / Math.max(0.25, simSpeed); while(acc>=step){ simulate(step); acc-=step; } }
    render();
  }catch(e){
    // Show any silent Safari errors in the Chronicle instead of freezing
    logLine("⚠️ Runtime error: "+(e&&e.message?e.message:e));
  }
  requestAnimationFrame(frame);
}

/* ---------- Kickoff (with safety reseed if needed) ---------- */
multiverse.ensureUniverse(1); multiverse.ensureUniverse(2); multiverse.connect(1,2); multiverse.currentId=1;
centerView();
updateButtons();
logLine("Welcome to the ∞ Multiverse Evolver. 🌌 Double-tap to pause/play.");
requestAnimationFrame(frame);

// If Safari briefly reports zero size and nothing draws, force a reseed + recenter soon
setTimeout(()=>{ const u=multiverse.currentUniverse(); if(u && u.creatures.length<10){ u.spawnInitial(); centerView(); logLine("Auto-seeded life (startup safeguard)."); } }, 1200);

})(); // IIFE
</script>
</body>
</html>